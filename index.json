[{"categories":["PowerShell","Intune","ConfigMGR"],"contents":"Dynamic? In what way? When I say the packages are dynamic, I mean that you don\u0026rsquo;t have to update the application package when a new version is released by the vendor.\nThere are caveats to both methods that we walk through below, there are also other community and paid for tools to do similar things.\nHowever, the reason I wrote this post and started focusing on packaging applications in this was to avoid having support tickets when a new version is released, I also wanted to use this with ConfigMGR and Intune without the requirement of additional modules.\nShow me the way! Well lets show you a couple ways to do this, Web (HTML) Scraping and using the GitHub API.\nWeb Scraping In my opinion, this is the most flawed method, as this replies on the website layout and/or table structure to stay the same as when you write your script. However, it is still an option and it works really well.\nTo be able to get the data from the tables in PowerShell we are going to need to use Invoke-WebRequest, Normally this would be super easy to use as it parses the HTML data for you. However, as this script will run as system in Intune you will need to launch it with -UseBasicParsing which complicates things a little more.\nFor this example we will use the Microsoft Remote Desktop Client , Are you ready? Lets begin. (You can achieve this using API Calls, However, this is a good example of table structure for Web Scraping)\nDetection   Lets start by looking at the way we obtain the latest version and check it again the version in the registry.\nAs you can see from the image below, there is a version table right at the top of the web page.\nIf you press F12 and open the developer options, you can click through the HTML sections in the Elements tab and find the table like below;\nAs you can see from the snippet below we have to use a HTMLContent COM object to parse the HTML data so we can interact with the tables.\nIn it\u0026rsquo;s simplest form we get the RawContent and then write it to the IHTMLDocument2 object with the COM object, giving us the functionality work with the tables.\nfunction Get-LatestVersion { [String]$URL = \u0026#34;https://docs.microsoft.com/en-us/windows-server/remote/remote-desktop-services/clients/windowsdesktop-whatsnew\u0026#34; $WebResult = Invoke-WebRequest -Uri $URL -UseBasicParsing $WebResultHTML = $WebResult.RawContent $HTML = New-Object -Com \u0026#34;HTMLFile\u0026#34; $HTML.IHTMLDocument2_write($WebResultHTML) $Tables = @($html.all.tags(\u0026#39;table\u0026#39;)) $LatestVer = $null [System.Collections.ArrayList]$LatestVer = New-Object -TypeName psobject for ($i = 0; $i -le $tables.count; $i++) { $table = $tables[0] $titles = @() $rows = @($table.Rows) ## Go through all of the rows in the table foreach ($row in $rows) { $cells = @($row.Cells) ## If we\u0026#39;ve found a table header, remember its titles if ($cells[0].tagName -eq \u0026#34;TH\u0026#34;) { $titles = @($cells | ForEach-Object { (\u0026#34;\u0026#34; + $_.InnerText).Trim() }) continue } $resultObject = [Ordered] @{} $counter = 0 foreach ($cell in $cells) { $title = $titles[$counter] if (-not $title) { continue } $resultObject[$title] = (\u0026#34;\u0026#34; + $cell.InnerText).Trim() $Counter++ } #$Version_Data = @() $Version_Data = [PSCustomObject]@{ \u0026#39;LatestVersion\u0026#39; = $resultObject.\u0026#39;Latest version\u0026#39; } $LatestVer.Add($Version_Data) | Out-null } } $LatestVer } Let\u0026rsquo;s take a closer look at the interaction with the tables, as you can see the variable $Tables uses the the $HTML variable which contains the COM object data to select everything with the tag of table ($Tables = @($html.all.tags('table'))). From this point it uses a for loop to gather the table data, until finally we decide which part of the table we want to use.\nFor example, We are focusing on the latest version, so if you run the for loop manually and look at $resultObject in PowerShell it will return something like this; From this point you can create a PSCustomObject with the table header you want. Now this is kind of over complicating it for this example as you could just return $resultObject.'Latest version' however, I use this loop for other methods and keeping it in this format helps me standardise the way I work, but it also gives you the ability to use if for other things too.\nAll of this is wrapped inside a function (Get-LatestVersion) as I plan on using the same script for the detection method as for the install, but I also like to re-check in my install script that the application definitely is not installed before the install action executes. If you look at the Detect-Application function you can see that I check both the 64-bit and 32-bit registry locations with an IF statement based on the variables below;\n$UninstallKey = \u0026#34;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\\u0026#34; $UninstallKeyWow6432Node = \u0026#34;HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\\u0026#34; $LatestVersion = ((Get-LatestVersion | Get-Unique | Sort-Object $_.LatestVersion)[0]).LatestVersion $AppName = \u0026#34;Remote Desktop\u0026#34; function Detect-Application { IF (((Get-ChildItem -Path $UninstallKey | Get-ItemProperty | Where-Object {$_.DisplayName -like \u0026#34;*$AppName*\u0026#34;}).DisplayVersion -Match $LatestVersion) -or ((Get-ChildItem -Path $UninstallKeyWow6432Node | Get-ItemProperty | Where-Object {$_.DisplayName -like \u0026#34;*$AppName*\u0026#34;}).DisplayVersion -Match $LatestVersion)) { $True } } The IF statement uses an -or operator, meaning if one of the conditions matches then run the code within the brackets below. As you can see from the variables the $LatestVersion uses the Get-LatestVersion function which is used to match the display version in the registry.\nThis the fundamental foundation of the operation, as we can now detect the application without using any additional modules in the next section we will look at the download and installation of the app.\n  Download Link   Now we know that we can Detect the application, lets look at obtaining the download link.\nIf you look at the below snippet, you can see we use a variable which calls a function to get the download link ($DownloadLink = Get-DownloadLink). For this to work there is a reliance on the the Variable $Arch been set, by default this is set to 64-bit. However, this is available as a command line parameter.\nparam ( [ValidateSet(\u0026#39;64-bit\u0026#39;,\u0026#39;32-bit\u0026#39;,\u0026#39;ARM64\u0026#39;)] [String]$Arch = \u0026#39;64-bit\u0026#39;, [ValidateSet(\u0026#39;Install\u0026#39;,\u0026#39;Uninstall\u0026#39;,\u0026#34;Detect\u0026#34;)] [string]$ExecutionType, [string]$DownloadPath = \u0026#34;$env:Temp\\RDInstaller\\\u0026#34; ) $DownloadLink = Get-DownloadLink Lets take a look at the Get-DownloadLink function, the basics of getting the data and writing it to an HTML COM object is the same as the detection method, however this time we do not need to look at a table, we are specifically looking for a link which matched the $Arch variable.\nfunction Get-DownloadLink { $URL = \u0026#34;https://docs.microsoft.com/en-us/windows-server/remote/remote-desktop-services/clients/windowsdesktop\u0026#34; $WebResult = Invoke-WebRequest -Uri $URL -UseBasicParsing $WebResultHTML = $WebResult.RawContent $HTML = New-Object -Com \u0026#34;HTMLFile\u0026#34; $HTML.IHTMLDocument2_write($WebResultHTML) ($HTML.links | Where-Object {$_.InnerHTMl -Like \u0026#34;*$Arch*\u0026#34;}).href } If you look at the web page for the downloads you will see that the links are in an unordered list;\nAgain if you hit F12 and look at the html content behind the table, you will see the data we are looking for.\nTo get this using the script we simply run ($HTML.links | Where-Object {$_.InnerHTMl -Like \u0026quot;*$Arch*\u0026quot;}).href simple right?\n  Download \u0026amp; Install   Before we look at the install function, lets look at the logic that calls the install.\nLets just assume you called the script with the Install execution type (.\\\u0026lt;ScriptName.ps1 -ExecutionType Install) or launched it without any parameters.\nLets look inside the default section highlighted below, firstly it will check if the latest version of the application is not installed using an IF statement, ELSE return that it is already installed.\nIf the application is not installed it then proceeds to attempt the installation in a try{} catch{} statement. The basics of this is as it says, it will try the install, if it fails it will catch it and throw back the Write-Error text.\nswitch ($ExecutionType) { Detect { Detect-Application } Uninstall { try { Uninstall-Application -ErrorAction Stop \u0026#34;Uninstallation Complete\u0026#34; } catch { Write-Error \u0026#34;Failed to Install $AppName\u0026#34; } } Default { IF (!(Detect-Application)) { try { \u0026#34;The latest version is not installed, Attempting install\u0026#34; Install-Application -ErrorAction Stop \u0026#34;Installation Complete\u0026#34; } catch { Write-Error \u0026#34;Failed to Install $AppName\u0026#34; } } ELSE { \u0026#34;The Latest Version ($LatestVersion) of $AppName is already installed\u0026#34; } } } Lets take a look at the Install-Application function that is called in the statement.\nLets Break it down into stages.\n Checks if the $DownloadPath exists, if not it will try to create it. Download the installer from the Link to the Download folder ($DownloadPath) Install the MSI with the additional command line arguments \u0026quot;$DownloadPath\\$InstallerName\u0026quot;\u0026quot; /qn /norestart /l* \u0026quot;\u0026quot;$DownloadPath\\RDINSTALL$(get-Date -format yyyy-MM-dd).log\u0026quot;\u0026quot;  When using double quotes (\u0026quot;) inside double quotes you must double them up. For Example \u0026quot;The file is located: \u0026quot;\u0026quot;$Variable\\Path.txt\u0026quot;\u0026quot;\u0026quot;\n $LatestVersion = ((Get-LatestVersion | Get-Unique | Sort-Object $_.LatestVersion)[0]).LatestVersion $InstallerName = \u0026#34;RemoteDesktop-$LatestVersion-$Arch.msi\u0026#34; function Install-Application { IF (!(Test-Path $DownloadPath)) { try { Write-Verbose \u0026#34;$DownloadPath Does not exist, Creating the folder\u0026#34; MKDIR $DownloadPath -ErrorAction Stop | Out-Null } catch { Write-Verbose \u0026#34;Failed to create folder $DownloadPath\u0026#34; } } try { Write-Verbose \u0026#34;Attempting client download\u0026#34; Invoke-WebRequest -Usebasicparsing -URI $DownloadLink -Outfile \u0026#34;$DownloadPath\\$InstallerName\u0026#34; -ErrorAction Stop } catch { Write-Error \u0026#34;Failed to download $AppName\u0026#34; } try { \u0026#34;Installing $AppName v$($LatestVersion)\u0026#34; Start-Process \u0026#34;MSIEXEC.exe\u0026#34; -ArgumentList \u0026#34;/I \u0026#34;\u0026#34;$DownloadPath\\$InstallerName\u0026#34;\u0026#34; /qn /norestart /l* \u0026#34;\u0026#34;$DownloadPath\\RDINSTALL$(get-Date -format yyyy-MM-dd).log\u0026#34;\u0026#34;\u0026#34; -Wait } catch { Write-Error \u0026#34;failed to Install $AppName\u0026#34; } }   Uninstall   As we have a dynamic installation, we want the same for the uninstall right?\nWell this is also achievable, take a look the the Uninstall-Application function below;\n$UninstallKey = \u0026#34;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\\u0026#34; $UninstallKeyWow6432Node = \u0026#34;HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\\u0026#34; $AppName = \u0026#34;Remote Desktop\u0026#34; function Uninstall-Application { try { \u0026#34;Uninstalling $AppName\u0026#34; IF (Get-ChildItem -Path $UninstallKey | Get-ItemProperty | Where-Object {$_.DisplayName -like \u0026#34;*$AppName*\u0026#34;} -ErrorAction SilentlyContinue) { \u0026#34;Uninstalling $AppName\u0026#34; $UninstallGUID = (Get-ChildItem -Path $UninstallKey | Get-ItemProperty | Where-Object {$_.DisplayName -like \u0026#34;*$AppName*\u0026#34;}).PSChildName $UninstallArgs = \u0026#34;/X \u0026#34; + $UninstallGUID + \u0026#34; /qn\u0026#34; Start-Process \u0026#34;MSIEXEC.EXE\u0026#34; -ArgumentList $UninstallArgs -Wait } IF (Get-ChildItem -Path $UninstallKeyWow6432Node | Get-ItemProperty | Where-Object {$_.DisplayName -like \u0026#34;*$AppName*\u0026#34;} -ErrorAction SilentlyContinue) { \u0026#34;Uninstalling $AppName\u0026#34; $UninstallGUID = (Get-ChildItem -Path $UninstallKeyWow6432Node | Get-ItemProperty | Where-Object {$_.DisplayName -like \u0026#34;*$AppName*\u0026#34;}).UninstallString $UninstallArgs = \u0026#34;/X \u0026#34; + $UninstallGUID + \u0026#34; /qn\u0026#34; Start-Process \u0026#34;MSIEXEC.EXE\u0026#34; -ArgumentList $UninstallArgs -Wait } } catch { Write-Error \u0026#34;failed to Uninstall $AppName\u0026#34; } } This is using some of the same logic as the Detection method, It checks both the 64-bit and the 32-bit registry keys to see if an application that is like the display name of our application.\nIf a registry entry is detected, it will obtain the Key Name in this case as we are dealing with an MSI. This is because the MSI Key name is the GUID, it will then build up the MSIEXEC arguments for the uninstall. After it has completed both steps it will then process with the uninstallation.\n  Finished Script   If you compile all of the sections together with a little bit of formatting you will end up with a script like the one below.\nExamples To Install the 64-Bit version .\\Dynamic-RemoteDesktopClient.ps1\nTo Install the 32-Bit version .\\Dynamic-RemoteDesktopClient.ps1 -Arch '32-bit'\nTo detect the installation only .\\Dynamic-RemoteDesktopClient.ps1 -ExecutionType Detect\nTo uninstall the application .\\Dynamic-RemoteDesktopClient.ps1 -ExecutionType Uninstall\nYou will need to change the param block variable for $ExecutionType to $ExecutionType = Detect when using this as a detection method within Intune or ConfigMGR.\n \u0026lt;# .SYNOPSISThis is a script to Dynamically Detect, Install and Uninstall the Microsoft Remote Desktop Client for Windows. https://docs.microsoft.com/en-us/windows-server/remote/remote-desktop-services/clients/windowsdesktop .DESCRIPTIONUse this script to detect, install or uninstall the Microsoft Remote Desktop client for Windows .PARAMETERArch Select the architecture you would like to install, select from the following - 64-bit (Default) - 32-bit - ARM64 .PARAMETERExecutionType Select the Execution type, this determines if you will be detecting, installing uninstalling the application. The options are as follows; - Install (Default) - Detect - Uninstall .ParameterDownloadPath The location you would like the downloaded installer to go. Default: $env:TEMP\\RDInstaller .NOTESVersion: 1.2 Author: David Brook Creation Date: 21/02/2021 Purpose/Change: Initial script development #\u0026gt; param ( [ValidateSet(\u0026#39;64-bit\u0026#39;,\u0026#39;32-bit\u0026#39;,\u0026#39;ARM64\u0026#39;)] [String]$Arch = \u0026#39;64-bit\u0026#39;, [ValidateSet(\u0026#39;Install\u0026#39;,\u0026#39;Uninstall\u0026#39;,\u0026#34;Detect\u0026#34;)] [string]$ExecutionType, [string]$DownloadPath = \u0026#34;$env:Temp\\RDInstaller\\\u0026#34; ) function Get-LatestVersion { [String]$URL = \u0026#34;https://docs.microsoft.com/en-us/windows-server/remote/remote-desktop-services/clients/windowsdesktop-whatsnew\u0026#34; $WebResult = Invoke-WebRequest -Uri $URL -UseBasicParsing $WebResultHTML = $WebResult.RawContent $HTML = New-Object -Com \u0026#34;HTMLFile\u0026#34; $HTML.IHTMLDocument2_write($WebResultHTML) $Tables = @($html.all.tags(\u0026#39;table\u0026#39;)) $LatestVer = $null [System.Collections.ArrayList]$LatestVer = New-Object -TypeName psobject for ($i = 0; $i -le $tables.count; $i++) { $table = $tables[0] $titles = @() $rows = @($table.Rows) ## Go through all of the rows in the table foreach ($row in $rows) { $cells = @($row.Cells) ## If we\u0026#39;ve found a table header, remember its titles if ($cells[0].tagName -eq \u0026#34;TH\u0026#34;) { $titles = @($cells | ForEach-Object { (\u0026#34;\u0026#34; + $_.InnerText).Trim() }) continue } $resultObject = [Ordered] @{} $counter = 0 foreach ($cell in $cells) { $title = $titles[$counter] if (-not $title) { continue } $resultObject[$title] = (\u0026#34;\u0026#34; + $cell.InnerText).Trim() $Counter++ } #$Version_Data = @() $Version_Data = [PSCustomObject]@{ \u0026#39;LatestVersion\u0026#39; = $resultObject.\u0026#39;Latest version\u0026#39; } $LatestVer.Add($Version_Data) | Out-null } } $LatestVer } function Get-DownloadLink { $URL = \u0026#34;https://docs.microsoft.com/en-us/windows-server/remote/remote-desktop-services/clients/windowsdesktop\u0026#34; $WebResult = Invoke-WebRequest -Uri $URL -UseBasicParsing $WebResultHTML = $WebResult.RawContent $HTML = New-Object -Com \u0026#34;HTMLFile\u0026#34; $HTML.IHTMLDocument2_write($WebResultHTML) ($HTML.links | Where-Object {$_.InnerHTMl -Like \u0026#34;*$Arch*\u0026#34;}).href } function Detect-Application { IF (((Get-ChildItem -Path $UninstallKey | Get-ItemProperty | Where-Object {$_.DisplayName -like \u0026#34;*$AppName*\u0026#34;}).DisplayVersion -Match $LatestVersion) -or ((Get-ChildItem -Path $UninstallKeyWow6432Node | Get-ItemProperty | Where-Object {$_.DisplayName -like \u0026#34;*$AppName*\u0026#34;}).DisplayVersion -Match $LatestVersion)) { $True } } function Install-Application { IF (!(Test-Path $DownloadPath)) { try { Write-Verbose \u0026#34;$DownloadPath Does not exist, Creating the folder\u0026#34; MKDIR $DownloadPath -ErrorAction Stop | Out-Null } catch { Write-Verbose \u0026#34;Failed to create folder $DownloadPath\u0026#34; } } try { Write-Verbose \u0026#34;Attempting client download\u0026#34; Invoke-WebRequest -Usebasicparsing -URI $DownloadLink -Outfile \u0026#34;$DownloadPath\\$InstallerName\u0026#34; -ErrorAction Stop } catch { Write-Error \u0026#34;Failed to download $AppName\u0026#34; } try { \u0026#34;Installing $AppName v$($LatestVersion)\u0026#34; Start-Process \u0026#34;MSIEXEC.exe\u0026#34; -ArgumentList \u0026#34;/I \u0026#34;\u0026#34;$DownloadPath\\$InstallerName\u0026#34;\u0026#34; /qn /norestart /l* \u0026#34;\u0026#34;$DownloadPath\\RDINSTALL$(get-Date -format yyyy-MM-dd).log\u0026#34;\u0026#34;\u0026#34; -Wait } catch { Write-Error \u0026#34;failed to Install $AppName\u0026#34; } } function Uninstall-Application { try { \u0026#34;Uninstalling $AppName\u0026#34; IF (Get-ChildItem -Path $UninstallKey | Get-ItemProperty | Where-Object {$_.DisplayName -like \u0026#34;*$AppName*\u0026#34;} -ErrorAction SilentlyContinue) { \u0026#34;Uninstalling $AppName\u0026#34; $UninstallGUID = (Get-ChildItem -Path $UninstallKey | Get-ItemProperty | Where-Object {$_.DisplayName -like \u0026#34;*$AppName*\u0026#34;}).PSChildName $UninstallArgs = \u0026#34;/X \u0026#34; + $UninstallGUID + \u0026#34; /qn\u0026#34; Start-Process \u0026#34;MSIEXEC.EXE\u0026#34; -ArgumentList $UninstallArgs -Wait } IF (Get-ChildItem -Path $UninstallKeyWow6432Node | Get-ItemProperty | Where-Object {$_.DisplayName -like \u0026#34;*$AppName*\u0026#34;} -ErrorAction SilentlyContinue) { \u0026#34;Uninstalling $AppName\u0026#34; $UninstallGUID = (Get-ChildItem -Path $UninstallKeyWow6432Node | Get-ItemProperty | Where-Object {$_.DisplayName -like \u0026#34;*$AppName*\u0026#34;}).UninstallString $UninstallArgs = \u0026#34;/X \u0026#34; + $UninstallGUID + \u0026#34; /qn\u0026#34; Start-Process \u0026#34;MSIEXEC.EXE\u0026#34; -ArgumentList $UninstallArgs -Wait } } catch { Write-Error \u0026#34;failed to Uninstall $AppName\u0026#34; } } $UninstallKey = \u0026#34;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\\u0026#34; $UninstallKeyWow6432Node = \u0026#34;HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\\u0026#34; $LatestVersion = ((Get-LatestVersion | Get-Unique | Sort-Object $_.LatestVersion)[0]).LatestVersion $InstallerName = \u0026#34;RemoteDesktop-$LatestVersion-$Arch.msi\u0026#34; $AppName = \u0026#34;Remote Desktop\u0026#34; $DownloadLink = Get-DownloadLink switch ($ExecutionType) { Detect { Detect-Application } Uninstall { try { Uninstall-Application -ErrorAction Stop \u0026#34;Uninstallation Complete\u0026#34; } catch { Write-Error \u0026#34;Failed to Install $AppName\u0026#34; } } Default { IF (!(Detect-Application)) { try { \u0026#34;The latest version is not installed, Attempting install\u0026#34; Install-Application -ErrorAction Stop \u0026#34;Installation Complete\u0026#34; } catch { Write-Error \u0026#34;Failed to Install $AppName\u0026#34; } } ELSE { \u0026#34;The Latest Version ($LatestVersion) of $AppName is already installed\u0026#34; } } }   That wraps up the Web Scraping method, I hope this proves useful when trying to make your apps more dynamic.\nGitHub API Using API calls is a better way to do dynamic updates. Some vendors host their content on GitHub  as this provides build pipelines, wikis, projects and a whole host of other things. This is the method that is least likely to change, and if it does it will be documented using the GitHub API Docs .\nFor this example we are going to look at using Git for Windows , we will be using their GitHub Repo  to query the version and also get the download.\nGitHub has a rate limit for the API calls, unautenticated calls has a rate limit of 60, GitHub authenticated accounts has a limit of 5000 and GitHub Enterprise accounts has a limit of 15000 calls. Each time the script is launched it used1 call, so in terms of a detection and installation you will need a 2 api calls. You will need to take this into account if you plan to package multiple applications in this way, you could use multiple accounts and randomise the PAC Key from an array, however this is something that should be highlighted.\n GIT Detection   Lets start by looking at the latest releases page.\nThe first thing you may notice that it automatically redirects the URL, but we just want to check the version.\nNow that we know what the latest version is on the GitHub page, lets take a look at the API. If you change the URL in your browser to https://api.github.com/repos/git-for-windows/git/releases/latest, you will see a JSON response like the below.\n{ \u0026#34;url\u0026#34;: \u0026#34;https://api.github.com/repos/git-for-windows/git/releases/37800609\u0026#34;, \u0026#34;assets_url\u0026#34;: \u0026#34;https://api.github.com/repos/git-for-windows/git/releases/37800609/assets\u0026#34;, \u0026#34;upload_url\u0026#34;: \u0026#34;https://uploads.github.com/repos/git-for-windows/git/releases/37800609/assets{?name,label}\u0026#34;, \u0026#34;html_url\u0026#34;: \u0026#34;https://github.com/git-for-windows/git/releases/tag/v2.30.1.windows.1\u0026#34;, \u0026#34;id\u0026#34;: 37800609, \u0026#34;author\u0026#34;: { \u0026#34;login\u0026#34;: \u0026#34;git-for-windows-ci\u0026#34;, \u0026#34;id\u0026#34;: 24522801, \u0026#34;node_id\u0026#34;: \u0026#34;MDQ6VXNlcjI0NTIyODAx\u0026#34;, \u0026#34;avatar_url\u0026#34;: \u0026#34;https://avatars.githubusercontent.com/u/24522801?v=4\u0026#34;, \u0026#34;gravatar_id\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://api.github.com/users/git-for-windows-ci\u0026#34;, \u0026#34;html_url\u0026#34;: \u0026#34;https://github.com/git-for-windows-ci\u0026#34;, \u0026#34;followers_url\u0026#34;: \u0026#34;https://api.github.com/users/git-for-windows-ci/followers\u0026#34;, \u0026#34;following_url\u0026#34;: \u0026#34;https://api.github.com/users/git-for-windows-ci/following{/other_user}\u0026#34;, \u0026#34;gists_url\u0026#34;: \u0026#34;https://api.github.com/users/git-for-windows-ci/gists{/gist_id}\u0026#34;, \u0026#34;starred_url\u0026#34;: \u0026#34;https://api.github.com/users/git-for-windows-ci/starred{/owner}{/repo}\u0026#34;, \u0026#34;subscriptions_url\u0026#34;: \u0026#34;https://api.github.com/users/git-for-windows-ci/subscriptions\u0026#34;, \u0026#34;organizations_url\u0026#34;: \u0026#34;https://api.github.com/users/git-for-windows-ci/orgs\u0026#34;, \u0026#34;repos_url\u0026#34;: \u0026#34;https://api.github.com/users/git-for-windows-ci/repos\u0026#34;, \u0026#34;events_url\u0026#34;: \u0026#34;https://api.github.com/users/git-for-windows-ci/events{/privacy}\u0026#34;, \u0026#34;received_events_url\u0026#34;: \u0026#34;https://api.github.com/users/git-for-windows-ci/received_events\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;User\u0026#34;, \u0026#34;site_admin\u0026#34;: false }, \u0026#34;node_id\u0026#34;: \u0026#34;MDc6UmVsZWFzZTM3ODAwNjA5\u0026#34;, \u0026#34;tag_name\u0026#34;: \u0026#34;v2.30.1.windows.1\u0026#34;, \u0026#34;target_commitish\u0026#34;: \u0026#34;main\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Git for Windows 2.30.1\u0026#34;,  \u0026#34;draft\u0026#34;: false, \u0026#34;prerelease\u0026#34;: false, \u0026#34;created_at\u0026#34;: \u0026#34;2021-02-09T12:53:04Z\u0026#34;, \u0026#34;published_at\u0026#34;: \u0026#34;2021-02-09T13:41:03Z\u0026#34;, \u0026#34;assets\u0026#34;: [ All objects in assets, this is just a snippet] } If you look at the highlighted line above, you will notice that the versions matches the one on the latest release page.\nNow we know what property within the API we are looking for and how it displays, we can head into PowerShell and start working on the detection.\nFirst of all we need to get the latest version, to do this we first perform and API Call to get all of the information and store the information in the $RestResult variable.\nTake a look at the below snippet;\nparam ( [ValidateSet(\u0026#39;64-bit\u0026#39;,\u0026#39;32-bit\u0026#39;,\u0026#39;ARM64\u0026#39;)] [String]$Arch = \u0026#39;64-bit\u0026#39;, [ValidateSet(\u0026#39;Install\u0026#39;,\u0026#39;Uninstall\u0026#39;,\u0026#34;Detect\u0026#34;)] [string]$ExecutionType = \u0026#34;Detect\u0026#34;, [string]$DownloadPath = \u0026#34;$env:Temp\\GitInstaller\\\u0026#34;, [string]$GITPAC ) ############################################################################## ##################### Get the Information from the API ####################### ############################################################################## [String]$GitHubURI = \u0026#34;https://api.github.com/repos/git-for-windows/git/releases/latest\u0026#34; IF ($GITPAC) { $RestResult = Invoke-RestMethod -Method GET -Uri $GitHubURI -ContentType \u0026#34;application/json\u0026#34; -Headers @{Authorization = \u0026#34;token $GITPAC\u0026#34;} } ELSE { $RestResult = Invoke-RestMethod -Method GET -Uri $GitHubURI -ContentType \u0026#34;application/json\u0026#34; } ############################################################################## ########################## Set Required Variables ############################ ############################################################################## $LatestVersion = $RestResult.name.split()[-1] } The first thing to note on this snippet is the method it will use to connect to the API, If you specify a Personal Access Token with the -GITPAC parameter or via the variable in the script you will be able to have 5000 API calls for your application installs.\nIn short we specify the $URL variable and then run a GET request with Invoke-RestMethod and specify that we want the output as application/json. Once it has the data we want to then format the $LatestVersion variable to return just the version number, for this we use the .split() operator, by default this splits on spaces, you can specify other characters to split it with by adding in something like '.' and it would split the string at every point there is a dot. Now we have split the string, we want to select the index, for this example as the version number is at the end we want to select the index [-1]. If the index was at the start we would use [0], feel free to experiment with this.\nThis variable is then used to call the Detect-Application function which will return True if the application is installed, otherwise it will return null.\n$LatestVersion = $RestResult.name.split()[-1] $UninstallKey = \u0026#34;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\\u0026#34; $UninstallKeyWow6432Node = \u0026#34;HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\\u0026#34; $DetectionString = \u0026#34;Git version\u0026#34; $AppName = \u0026#34;Git For Windows\u0026#34; ############################################################################## ########################## Application Detection ############################# ############################################################################## function Detect-Application { IF (((Get-ChildItem -Path $UninstallKey | Get-ItemProperty | Where-Object {$_.DisplayName -like \u0026#34;*$DetectionString*\u0026#34;}).DisplayVersion -Match $LatestVersion) -or ((Get-ChildItem -Path $UninstallKeyWow6432Node | Get-ItemProperty | Where-Object {$_.DisplayName -like \u0026#34;*$DetectionString*\u0026#34;}).DisplayVersion -Match $LatestVersion)) { Write-Output \u0026#34;$AppName is installed\u0026#34; $True } }   GIT Download Link   If you take a look back at the latest releases page, and scroll down to Assets, if you hover over one of them you will see the URL it links to in the bottom left-hand corner of your browser. Now we know that we can Detect the application, lets look at obtaining the download link.\nIf you look at the script snippet below, you can see that we are still using the $RestResult to obtain the download link. To get the download link for the architecture you specify we first have to build up the $EXEName Variable, this uses the $LatestVersion and $Arch variables to bring the name together.\nOnce the name EXE Name is sorted, we then use this to get the link, by using the Where-Object function to select the download URL from the asset where the $_.name matches $EXEName.\nparam ( [ValidateSet(\u0026#39;64-bit\u0026#39;,\u0026#39;32-bit\u0026#39;,\u0026#39;ARM64\u0026#39;)] [String]$Arch = \u0026#39;64-bit\u0026#39;, [ValidateSet(\u0026#39;Install\u0026#39;,\u0026#39;Uninstall\u0026#39;,\u0026#34;Detect\u0026#34;)] [string]$ExecutionType = \u0026#34;Detect\u0026#34;, [string]$DownloadPath = \u0026#34;$env:Temp\\GitInstaller\\\u0026#34;, [string]$GITPAC ) ############################################################################## ########################## Set Required Variables ############################ ############################################################################## $LatestVersion = $RestResult.name.split()[-1] $EXEName = \u0026#34;Git-$LatestVersion-$Arch.exe\u0026#34; $DownloadLink = ($RestResult.assets | Where-Object {$_.Name -Match $EXEName}).browser_download_url   GIT Download \u0026amp; Install   The Install logic is the same as web scraping, however we will cover it here too so you don\u0026rsquo;t need to scroll up.\nLets just assume you called the script with the Install execution type (.\\\u0026lt;ScriptName.ps1 -ExecutionType Install) or launched it without any parameters.\nLets look inside the default section highlighted below, firstly it will check if the latest version of the application is not installed using an IF statement, ELSE return that it is already installed.\nIf the application is not installed it then proceeds to attempt the installation in a try{} catch{} statement. The basics of this is as it says, it will try the installation, if it fails it will catch it and throw back the Write-Error text.\nposh switch ($ExecutionType) { Detect { Detect-Application } Uninstall { try { Uninstall-Application -ErrorAction Stop \u0026#34;Uninstallation Complete\u0026#34; } catch { Write-Error \u0026#34;Failed to Install $AppName\u0026#34; } } Default { IF (!(Detect-Application)) { try { \u0026#34;The latest version is not installed, Attempting install\u0026#34; Install-Application -ErrorAction Stop \u0026#34;Installation Complete\u0026#34; } catch { Write-Error \u0026#34;Failed to Install $AppName\u0026#34; } } ELSE { \u0026#34;The Latest Version is already installed\u0026#34; } } } Lets take a look at the Install-Application function that is called in the statement.\nLets Break it down into stages.\n Checks if the $DownloadPath exists, if not it will try to create it. Download the installer from the Link to the Download folder ($DownloadPath) Install the application with the additional command line arguments stored in the $InstallArgs variable.  param ( [ValidateSet(\u0026#39;64-bit\u0026#39;,\u0026#39;32-bit\u0026#39;,\u0026#39;ARM64\u0026#39;)] [String]$Arch = \u0026#39;64-bit\u0026#39;, [ValidateSet(\u0026#39;Install\u0026#39;,\u0026#39;Uninstall\u0026#39;,\u0026#34;Detect\u0026#34;)] [string]$ExecutionType = \u0026#34;Detect\u0026#34;, [string]$DownloadPath = \u0026#34;$env:Temp\\GitInstaller\\\u0026#34;, [string]$GITPAC ) $LatestVersion = $RestResult.name.split()[-1] $DownloadLink = ($RestResult.assets | Where-Object {$_.Name -Match $EXEName}).browser_download_url $EXEName = \u0026#34;Git-$LatestVersion-$Arch.exe\u0026#34; $InstallArgs = \u0026#34;/SP- /VERYSILENT /SUPPRESSMSGBOXES /NORESTART\u0026#34; $AppName = \u0026#34;Git For Windows\u0026#34; ############################################################################## ################## Application Installation/Uninstallation ################### ############################################################################## function Install-Application { # If the Download Path does not exist, Then try and crate it.  IF (!(Test-Path $DownloadPath)) { try { Write-Verbose \u0026#34;$DownloadPath Does not exist, Creating the folder\u0026#34; New-Item -Path $DownloadPath -ItemType Directory -ErrorAction Stop | Out-Null } catch { Write-Verbose \u0026#34;Failed to create folder $DownloadPath\u0026#34; } } # Once the folder exists, download the installer try { Write-Verbose \u0026#34;Downloading Application Binaries for $AppName\u0026#34; Invoke-WebRequest -Usebasicparsing -URI $DownloadLink -Outfile \u0026#34;$DownloadPath\\$EXEName\u0026#34; -ErrorAction Stop } catch { Write-Error \u0026#34;Failed to download application binaries\u0026#34; } # Once Downloaded, Install the application try { \u0026#34;Installing $AppName $($LatestVersion)\u0026#34; Start-Process \u0026#34;$DownloadPath\\$EXEName\u0026#34; -ArgumentList $InstallArgs -Wait } catch { Write-Error \u0026#34;Failed to Install $AppName, please check the transcript file ($TranscriptFile) for further details.\u0026#34; } }   GIT Uninstall   As we have a dynamic installation, we want the same for the uninstall right?\nWell this is also achievable, take a look the the Uninstall-Application function below;\nLets break this down,\n Check if an application is installed with a display name like the string stored in $DetectionString (Checks both 64 and 32 Uninstall Keys) If the application is installed, get the UninstallString from the key and store this in the $UninstallEXE variable. Uninstall the application using the $UninstallEXE with the command line arguments stored in the $UninstallArgs variable.  ############################################################################## ################## Application Installation/Uninstallation ################### ############################################################################## $UninstallKey = \u0026#34;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\\u0026#34; $UninstallKeyWow6432Node = \u0026#34;HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\\u0026#34; $DetectionString = \u0026#34;Git version\u0026#34; $UninstallArgs = \u0026#34;/VERYSILENT /NORESTART\u0026#34; function Uninstall-Application { try { IF (Get-ChildItem -Path $UninstallKey | Get-ItemProperty | Where-Object {$_.DisplayName -like \u0026#34;*$DetectionString*\u0026#34;} -ErrorAction SilentlyContinue) { \u0026#34;Uninstalling $AppName\u0026#34; $UninstallExe = (Get-ChildItem -Path $UninstallKey | Get-ItemProperty | Where-Object {$_.DisplayName -like \u0026#34;*$DetectionString*\u0026#34;}).UninstallString Start-Process $UninstallExe -ArgumentList $UninstallArgs -Wait } IF (Get-ChildItem -Path $UninstallKeyWow6432Node | Get-ItemProperty | Where-Object {$_.DisplayName -like \u0026#34;*$DetectionString*\u0026#34;} -ErrorAction SilentlyContinue) { \u0026#34;Uninstalling $AppName\u0026#34; $UninstallExe = (Get-ChildItem -Path $UninstallKeyWow6432Node | Get-ItemProperty | Where-Object {$_.DisplayName -like \u0026#34;*$DetectionString*\u0026#34;}).UninstallString Start-Process $UninstallExe -ArgumentList $UninstallArgs -Wait } } catch { Write-Error \u0026#34;failed to Uninstall $AppName\u0026#34; } }   GIT Finished Script   If you compile all of the sections together with a little bit of formatting you will end up with a script like the one below.\nExamples To install the 64-Bit version .\\Dynamic-GitforWindows.ps1\nTo install the 32-Bit version .\\Dynamic-GitforWindows.ps1 -Arch '32-bit'\nTo detect the installation only .\\Dynamic-GitforWindows.ps1 -ExecutionType Detect\nTo install the application with a Git Personal Access Key .\\Dynamic-GitforWindows.ps1 -ExecutionType Install -GITPAC \u0026lt;YourPAC\u0026gt;\nTo uninstall the application .\\Dynamic-GitforWindows.ps1 -ExecutionType Uninstall\nYou will need to change the param block variable for $ExecutionType to $ExecutionType = Detect when using this as a detection method within Intune or ConfigMGR.\n \u0026lt;# .SYNOPSISThis is a script to Dynamically Detect, Install and Uninstall the Git for Windows Client. https://gitforwindows.org/ .DESCRIPTIONUse this script to detect, install or uninstall the Git for Windows client. .PARAMETERArch Select the architecture you would like to install, select from the following - 64-bit (Default) - 32-bit - ARM64 .PARAMETERExecutionType Select the Execution type, this determines if you will be detecting, installing uninstalling the application. The options are as follows; - Install (Default) - Detect - Uninstall .ParameterDownloadPath The location you would like the downloaded installer to go. Default: $env:TEMP\\GitInstall .NOTESVersion: 1.0 Author: David Brook Creation Date: 21/02/2021 Purpose/Change: Initial script development #\u0026gt; param ( [ValidateSet(\u0026#39;64-bit\u0026#39;,\u0026#39;32-bit\u0026#39;,\u0026#39;ARM64\u0026#39;)] [String]$Arch = \u0026#39;64-bit\u0026#39;, [ValidateSet(\u0026#39;Install\u0026#39;,\u0026#39;Uninstall\u0026#39;,\u0026#34;Detect\u0026#34;)] [string]$ExecutionType = \u0026#34;Detect\u0026#34;, [string]$DownloadPath = \u0026#34;$env:Temp\\GitInstaller\\\u0026#34;, [string]$GITPAC ) $TranscriptFile = \u0026#34;$env:SystemRoot\\Logs\\Software\\GitForWindows_Dynamic_Install.Log\u0026#34; IF (-Not ($ExecutionType -Match \u0026#34;Detect\u0026#34;)) { Start-Transcript -Path $TranscriptFile } ############################################################################## ########################## Application Detection ############################# ############################################################################## function Detect-Application { IF (((Get-ChildItem -Path $UninstallKey | Get-ItemProperty | Where-Object {$_.DisplayName -like \u0026#34;*$DetectionString*\u0026#34;}).DisplayVersion -Match $LatestVersion) -or ((Get-ChildItem -Path $UninstallKeyWow6432Node | Get-ItemProperty | Where-Object {$_.DisplayName -like \u0026#34;*$DetectionString*\u0026#34;}).DisplayVersion -Match $LatestVersion)) { Write-Output \u0026#34;$AppName is installed\u0026#34; $True } } ############################################################################## ################## Application Installation/Uninstallation ################### ############################################################################## function Install-Application { # If the Download Path does not exist, Then try and crate it.  IF (!(Test-Path $DownloadPath)) { try { Write-Verbose \u0026#34;$DownloadPath Does not exist, Creating the folder\u0026#34; New-Item -Path $DownloadPath -ItemType Directory -ErrorAction Stop | Out-Null } catch { Write-Verbose \u0026#34;Failed to create folder $DownloadPath\u0026#34; } } # Once the folder exists, download the installer try { Write-Verbose \u0026#34;Downloading Application Binaries for $AppName\u0026#34; Invoke-WebRequest -Usebasicparsing -URI $DownloadLink -Outfile \u0026#34;$DownloadPath\\$EXEName\u0026#34; -ErrorAction Stop } catch { Write-Error \u0026#34;Failed to download application binaries\u0026#34; } # Once Downloaded, Install the application try { \u0026#34;Installing $AppName $($LatestVersion)\u0026#34; Start-Process \u0026#34;$DownloadPath\\$EXEName\u0026#34; -ArgumentList $InstallArgs -Wait } catch { Write-Error \u0026#34;Failed to Install $AppName, please check the transcript file ($TranscriptFile) for further details.\u0026#34; } } function Uninstall-Application { try { IF (Get-ChildItem -Path $UninstallKey | Get-ItemProperty | Where-Object {$_.DisplayName -like \u0026#34;*$DetectionString*\u0026#34;} -ErrorAction SilentlyContinue) { \u0026#34;Uninstalling $AppName\u0026#34; $UninstallExe = (Get-ChildItem -Path $UninstallKey | Get-ItemProperty | Where-Object {$_.DisplayName -like \u0026#34;*$DetectionString*\u0026#34;}).UninstallString Start-Process $UninstallExe -ArgumentList $UninstallArgs -Wait } IF (Get-ChildItem -Path $UninstallKeyWow6432Node | Get-ItemProperty | Where-Object {$_.DisplayName -like \u0026#34;*$DetectionString*\u0026#34;} -ErrorAction SilentlyContinue) { \u0026#34;Uninstalling $AppName\u0026#34; $UninstallExe = (Get-ChildItem -Path $UninstallKeyWow6432Node | Get-ItemProperty | Where-Object {$_.DisplayName -like \u0026#34;*$DetectionString*\u0026#34;}).UninstallString Start-Process $UninstallExe -ArgumentList $UninstallArgs -Wait } } catch { Write-Error \u0026#34;failed to Uninstall $AppName\u0026#34; } } ############################################################################## ##################### Get the Information from the API ####################### ############################################################################## [String]$GitHubURI = \u0026#34;https://api.github.com/repos/git-for-windows/git/releases/latest\u0026#34; IF ($GITPAC) { $RestResult = Invoke-RestMethod -Method GET -Uri $GitHubURI -ContentType \u0026#34;application/json\u0026#34; -Headers @{Authorization = \u0026#34;token $GITPAC\u0026#34;} } ELSE { $RestResult = Invoke-RestMethod -Method GET -Uri $GitHubURI -ContentType \u0026#34;application/json\u0026#34; } ############################################################################## ########################## Set Required Variables ############################ ############################################################################## $LatestVersion = $RestResult.name.split()[-1] $EXEName = \u0026#34;Git-$LatestVersion-$Arch.exe\u0026#34; $DownloadLink = ($RestResult.assets | Where-Object {$_.Name -Match $EXEName}).browser_download_url ############################################################################## ########################## Install/Uninstall Params ########################## ############################################################################## $UninstallKey = \u0026#34;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\\u0026#34; $UninstallKeyWow6432Node = \u0026#34;HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\\u0026#34; $DetectionString = \u0026#34;Git version\u0026#34; $UninstallArgs = \u0026#34;/VERYSILENT /NORESTART\u0026#34; $InstallArgs = \u0026#34;/SP- /VERYSILENT /SUPPRESSMSGBOXES /NORESTART\u0026#34; $AppName = \u0026#34;Git For Windows\u0026#34; ############################################################################## ############################# Do the Business ################################ ############################################################################## switch ($ExecutionType) { Detect { Detect-Application } Uninstall { try { Uninstall-Application -ErrorAction Stop \u0026#34;Uninstallation Complete\u0026#34; } catch { Write-Error \u0026#34;Failed to Install $AppName\u0026#34; } } Default { IF (!(Detect-Application)) { try { \u0026#34;The latest version is not installed, Attempting install\u0026#34; Install-Application -ErrorAction Stop \u0026#34;Installation Complete\u0026#34; } catch { Write-Error \u0026#34;Failed to Install $AppName\u0026#34; } } ELSE { \u0026#34;The Latest Version is already installed\u0026#34; } } } IF (-Not ($ExecutionType -Match \u0026#34;Detect\u0026#34;)) { Stop-Transcript }   Application Deployment Please see Creating Intune Win32 Apps for creating an Intune Win32 App Package.\n Lets look at how we deploy these applications from ConfigMG (MEMCM) and Intune.\nIntune   Load up Microsoft Endpoint Manager\n Select Apps from the navigation pane Select All Apps, Click Add Select App type Other\u0026gt;Windows app (Win32), Click Select Click Select app package file, Click the Blue Folder icon to open the browse window Select the .intunewin file you have created containing a copy of the script, Click Open and then click OK Fill out the Name and Publisher mandatory fields, and any other fields you desire Upload an icon if you desire, I would recommend doing this if you are deploying this to users via the Company Portal Click Next Enter your install command powershell.exe -executionpolicy bypass \u0026quot;.\\\u0026lt;Script Name.ps1\u0026gt;\u0026quot; Enter your uninstall command powershell.exe -executionpolicy bypass \u0026quot;.\\\u0026lt;Script Name.ps1\u0026gt;\u0026quot; -ExecutionType Uninstall Select your install behaviour as System Select your desired restart behaviour, Adding custom return codes if required Click Next Complete your OS Requirements, At a minimum you need to specify the Architecture and the minimum OS Version (e.g. 1607/1703 etc.) Click Next For Detection rules, select Use a custom detection script  Script File: Browse to a copy of the Script where the ExecutionType was amended to $ExecutionType = \u0026quot;Detect\u0026quot;.   Assign the application to your desired group  If you want to display the app in the company portal, it MUST be assigned to a group containing that user. Required Assignments will force the app to install, whereas Available will show this in the Company Portal. Click Next\n  Click Create    ConfigMGR   Head over to your Software Library and Start Creating an application in your desired folder\n General Tab - Select Manually Specify the application information General Information - Input the information for your app Software Center - Input any additional information and upload an icon Deployment Types - Click Add  Deployment Type - General - Change the Type to Script Installer Deployment Type - General Information - Provide a name and admin comments for your deployment type Deployment Type - Content  Content Location - Select your content location (Where you saved the PowerShell Script) Installation Program - Powershell.exe -ExecutionPolicy Bypass -File \u0026ldquo;..ps1\u0026rdquo; -ExecutionType Install Uninstallation Program - Powershell.exe -ExecutionPolicy Bypass -File \u0026ldquo;..ps1\u0026rdquo; -ExecutionType Uninstall Detection Method - Select Use a custom script and click Edit Script Type - PowerShell Script Content - Paste the content of the script adding Detect to the header (If you are using a GitHub PAC key, you will also need to add this in)   Installation Behavior - Install for System (Leave the reset as default or change as you desire) Dependencies \u0026amp; Requirements - Add any dependencies and requirements you wish   Click through the windows to complete the creation Deploy the app to your desired collection     During the installation and the uninstallation of the apps, there is a transcript of the session that is by default stored in C:\\Windows\\Logs\\Software. This will help in troubleshooting the install should you have any issues.\n Other Blogs and Tools Evergreen - Arron Parker I came across this when putting a tweet out to see if this post was worth while, Well worth a read.\nGitHub - aaronparker/Evergreen: Create evergeen Windows image build scripts with the latest version and download links for applications \nGaryTown Blog Post Using Ninite Apps - Gary Blok Ninite, is an awesome tool and Gary used this along with ConfigMGR to deploy applications with no content.\nConfigMgr Lab – Adding Ninite Apps – GARYTOWN ConfigMgr Blog \nPatchMy PC - A leader in the 3rd Party Patching world Now, this is not a community tool and it is licensed, however if you want to have this manage some of your Third Party apps with ConfigMGR, Intune or WSUS I would highly recommend them. This will save you a ton of time and help you on your way to having a fully patched estate.\nPatch My PC: Simplify Third-Party Patching in Microsoft SCCM and Intune \n","date":"31 March, 2021","image":["images/post/dynamicappinstall/FeaturedImage.png"],"permalink":"https://euc365.com/create-dynamic-application-packages-with-powershell/","tags":["PowerShell","Intune","GitHub API","HTML Web Scraping","Application Deployment","ConfigMGR"],"title":"Create Dynamic Application Packages with PowerShell"},{"categories":["Powershell","Intune","ConfigMGR","Windows Store for Business"],"contents":"What is the Windows Susbsystem for Linux? As per the Microsoft Documentation , The Windows Subsystem for Linux (WSL) is a new Windows 10 feature that enables you to run native Linux command-line tools directly on Windows, alongside your traditional Windows desktop and modern store apps.\nNow what does that mean? Can you run a full Linux setup in this way? Well the answer to that is NO unfortunately not. This tool is designed for developers and other users who use bash and other common Linux tools.\nI won\u0026rsquo;t go on as all of the information about WSL is in the link on the Microsoft Documentation text above.\nI will however provide the two scripts I use and wrote (nothing special just a couple of lines) for deployment and detection and demonstrate how to deploy with MEMCM.\nOnce the subsystem is installed it doesn\u0026rsquo;t mean that a Linux distribution is automatically installed. You can access these distributions via the Public Microsoft Store, however if you use this in an Enterprise and would like them added to your Enterprise Store you will need to contact your Store Admin. I will touch on how to add these just for simple convenience.\n(Un)Installation Script The script below can be used to both Enable and Disable the Windows Subsystem for Linux depending on what command line switch you specify. As mentioned this is not a complex script and it is easily edited for other Windows Optional Features\n\u0026lt;# .SYNOPSISThis script is used to Enable and Disable the Windows Subsystem for Linux Depending on the command line switch it is called with .DESCRIPTIONThis script is used to Enable and Disable the Windows Subsystem for Linux Depending on the command line switch it is called with .PARAMETEREnable Enables the Windows Subsystem for Linux .PARAMETERDisable Disables the Windows Subsystem for Linux .INPUTSNone .OUTPUTSNone .NOTESVersion: 1.0 Author: David Brook Creation Date: 13/08/2020 Purpose/Change: Initial script creation .EXAMPLEWindows_SubSystem_for_Linux.ps1 -Enable #\u0026gt; param ( [switch] $Enable, [switch] $Disable, [switch] ) IF ($Enable) { Enable-WindowsOptionalFeature -Online -FeatureName \u0026#34;Microsoft-Windows-Subsystem-Linux\u0026#34; -All -NoRestart } IF ($Disable) { Disable-WindowsOptionalFeature -Online -FeatureName \u0026#34;Microsoft-Windows-Subsystem-Linux\u0026#34; -NoRestart } Detection Script The script below can be for detection of the Windows Subsystem for Linux. I did try to use the Get-WindowsOptionalFeature -Online however it seemed to never be detected.\nIF ( Get-WmiObject -Class Win32_OptionalFeature | Where-Object {($_.Name -Match \u0026#34;Microsoft-Windows-Subsystem-Linux\u0026#34;) -and ($_.InstallState -eq 1)} ){ $True } MEMCM Application Head over to your Software Library and Start Creating an application in your desired folder\n General Tab - Select Manually Specify the application information General Information - Input your desired information, I called this Windows Subsystem for Linux but this is entirely your choice Software Center - Check the information and upload an icon if you would like, I used the below feel free to save it :D  \n Deployment Types - Click Add Deployment Type - General - Change the Type to Script Installer  Deployment Type - General Information - Provide a name and admin comments for your deployment type  Deployment Type - Content   Content Location - Select your content location (Where you saved the PowerShell Script) Installation Program - Powershell.exe -ExecutionPolicy Bypass -File \"..ps1\" -Enable Uninstall Program - Powershell.exe -ExecutionPolicy Bypass -File \"..ps1\" -Disable   Deployment Type - Detection Method - Select Use custom script to detect the presence of this deployment type and click Edit  Script Type - PowerShell Script Content - Use the detection method script above   Deployment Type - User Experience   Installation Behavior - Install for System (Leave the reset as default or change as you desire)   Deployment Type - Requirements - Add any requirements you want it to meet (The application does not require anything to install) Deployment Type - Dependencies - Add any dependencies you want it to meet (The application does not require any to install)  Finish both of the off the dialog windows through the summary panes and then deploy the applications to your desired collections. As mentioned above you will need to use a Linux distribution to use with the Windows Subsystem for Linux which are available in the Microsoft Store.\nIntune Application Please see Creating Intune Win32 Apps for creating an Intune Win32 App Package.\n  Select Apps from the navigation pane Select All Apps, Click Add Select App type Other\u0026gt;Windows app (Win32), Click Select Click Select app package file, Click the Blue Folder icon to open the browse windows Select the .intunewin file you have created containing a copy of the script above, Click Open and then click OK Fill out the Name and Publisher mandatory fields, and any other fields you desire Upload an icon if you desire, I would recommend doing this if you are deploying this to users via the Company Portal Click Next Enter your install command powershell.exe -executionpolicy bypass \u0026quot;.\\\u0026lt;Script Name.ps1\u0026gt;\u0026quot; -Enable Enter your uninstall command powershell.exe -executionpolicy bypass \u0026quot;.\\\u0026lt;Script Name.ps1\u0026gt;\u0026quot; -Disable Select your install behavior as System Select your desired restart behavior, Adding custom return codes if required WSL Does require a reboot to function, so please bear that in mind.\n  Click Next Complete your OS Requirements, At a minimum you need to specify the Architecture (x86/x64) and the minimum OS Version (e.g. 1607/1703 etc.) Click Next For Detection rules, select Use a custom detection script  Script File: Browse to a copy of the Detection Script provided above.   Assign the application to your desired group  If you want to display the app in the company portal, it MUST be assigned to a group containing that user. Required Assignments will force the app to install, whereas Available will show this in the Company Portal. Click Next\n  Click Create  Microsoft Store For Business The assignments are only user targeted, if you use groups and only the device you are using is in that group and not the user nothing will appear in the store.\n The Linux Distributions are available in the Microsoft Store for Business (MSfB), you and/or your company may restrict what apps can be installed from the store.\nBelow is a run down on how to deploy these Distros to Azure AD/Microsoft 365 Groups.\nWe will also look at how to deploy these in Offline mode.\nTo get started launch the Microsoft Store for Business  page.\n Click Sign in in the top right-hand corner and complete the sign-in process Type Linux in the search bar  You will receive the WSL Distros at the top if you use the Developer Tools category filter\n  Click on the Distro you would like to use/deploy Select you Licence Type, See Microsoft Documentation , Click Get App. Select the drop down below for your method of distribution.  Online   This option allows you to publish the Distro to the Microsoft Private Store.\n Click the Ellipses (\u0026hellip;) next to the Install button, Select Manage See the options in the drop downs below  Users   I would suggest using groups instead of assigning this to individual users. Please see the Private store availability section below\n If you want to deploy the application to just a specific user(s), you can just add them individually.\n Click Assign to Users Enter their Name or Email Address Select the User Click Assign Wait for the process to complete, click Close    Private store availability   I would suggest using Specific Groups for the distros, As this have a requirement of WSL been enabled, unless you deploy this as a required deployment.\n No one   Make sure you remove it from any Users in the users tab if you want to ensure No One has access to it.\n If you want to stop deploying the application, you simply have to select No one. No options for confirmation, it just removes ot from the Microsoft Store.\n  Everyone   If you want to deploy the application to your whole organisation, you simply have to select Everyone. No options for confirmation, it just makes this available in the Microsoft Store.  Specific Groups   If you want to deploy the application to a group of Users select Specific Groups.\n Click Assign Groups Enter the Name of the group Select the Group Click Add Groups         Offline   This option allows you to download the AppX Package for installation with DISM, PowerShell CmdLets or your MDM Provider.\n Click Manage Select your Platform, Minimum Version, Architecture, App Metadata You will then see something like the image below, this contains the Package Identity Name, Package family name, Package full name, Package format and the Supported architectures.  Click Download  I will demonstrate how to install this using PowerShell, however, please see the Distribute Offline Apps Microsoft Documentation for alternative methods.\n  Launch a Admin PowerShell console Browse to the directory the AppXBundle is stored Type Add-AppxPackage -Path .\\\u0026lt;PackageName\u0026gt;.AppxBundle, Hit Enter The distro is now installed  You can check that the distro is installed by using the Package Identity Name.\nGet-AppxPackage -Name \u0026lt;Package Identity Name\n    Distribute the content using your preferred method The Distro will now appear in your Start Menu  To Enable WSL for use the device must be restarted, If you see the below message, WSL is either not installed or your device is pending a reboot.\n Summary I hope that you find this useful if you ever need to deploy WSL. If you have any questions please do not hesitate to reach out using the Contact  page or in the comment section below.\nI had to use WSL the other day when deploying Docker Desktop as a dependency, the script came in handy for sure.\n ","date":"15 February, 2021","image":["images/post/deploywsl/FeaturedImage.png"],"permalink":"https://euc365.com/deploy-windows-subsystem-for-linux/","tags":["Powershell","Intune","ConfigMGR","Application Deployment","Windows Store for Business"],"title":"Deploy Windows Subsystem for Linux"},{"categories":["Powershell","Intune"],"contents":"Win32 Apps, What Are they? If you\u0026rsquo;re familiar with Configuration Manager/MEMCM then think of these files as your source directory, the difference being you are effectively zipping it up and then uploading to Intune.\nAccording to Microsoft, if you decide to use Win32 Apps, it is advised that you use these exclusively and NOT \u0026lsquo;Mix and Match\u0026rsquo; these with Line of Business applications when using Autopilot (See Microsoft Doc link below).\nWhat content can be in a Win32 App Package? The answer to that is well pretty much anything to a certain extent. These files are just proprietary files for Intune however under the hood they are just zip files that are then hashed and encoded.\nWhat uses are there for Win32 Apps? Well put, to Install apps. Now don\u0026rsquo;t be thrown by the 32 as these are not just for 32-bit apps, they can be used for any app.\nYou can use Win32 apps to just launch PowerShell scripts, Batch scripts, VBScripts etc. as long as you have a detection method if they succeed.\nMainly they are used for installing custom app packages like Greenshot, Citrix, PSADT Apps etc.\nMicrosoft Doc: Win32 app management in Microsoft Intune | Microsoft Docs\nPackage Creation Methods IntuneWinAppUtil Application The first method is creating a packaged using the GUI (Well kind of GUI) that is mentioned in the Microsoft Doc. Yiu can grab the utility from the below link;\nGitHub - Microsoft/Microsoft-Win32-Content-Prep-Tool: A tool to wrap Win32 App and then it can be uploaded to Intune\nIf you clone/download the files, and extract them to a suitable location to work with.\nLet\u0026rsquo;s get started. The below works on the assumption you have your files in a folder with noting other than those required for the app. (You don\u0026rsquo;t want to be uploading your entire desktop do you :P)\n Launch the IntuneWinAppUtil.exe Type/Paste your Source Directory (e.g. C:/Win 32 Apps/7-Zip), hit Enter. Type/Paste you setup file name (e.g. 7z2002-x64.exe or MyScript.ps1), hit Enter Type/Paste your Output Directory (e.g. C:/Win 32 Apps), hit Enter.  When prompted about catalogue files type N unless you are deploying to Windows S Mode, hit Enter  The window will automatically close when your .intunewin file is finished if you head over your output folder you will be able to get your file for upload. PowerShell PowerShell Gallery | IntuneWin32App 1.2.0\nFor you command-line gurus and script lovers out there, you will be pleased to know that there is a PowerShell module for bundling these your apps up, you can even go a step further and import them via a script, but we will save that for another post :D.\nYou can install the module using the following command;\n# # To install the module for the current user add -Scope CurrentUser to the below command # Install-Module IntuneWin32App Once you have the module installed you can type a command like this;\n# # Setup File example: Powershell.ps1, setup.exe, MyInstaller.msi # New-IntuneWin32AppPackage -SourceFolder \u0026#34;C:\\Win32 Apps\\7-Zip\u0026#34; -OutputFolder \u0026#34;C:\\Win32 Apps\\Outputs\u0026#34; -SetupFile 7z2002-x64.exe This command will create a .intunewin file in the output location named 7z2002-x64.intunewin, this is because it takes the installers name for the output. Unfortunately at the time of writing this, you can\u0026rsquo;t do it natively with this module. However, you can add a Rename-Item into your script to change it.\nUsing the packages with Intune Head over to Microsoft Endpoint Manager admin center (Intune) to to get started\n Select Apps from the navigation pane Select All Apps, Click Add Select App type Other\u0026gt;Windows app (Win32), Click Select  Click Select app package file, Click the Blue Folder icon to open the browse windows Select the .intunewin file you have created, Click Open and then click OK Fill out the Name and Publisher mandatory fields, and any other fields you desire Upload an icon if you desire, I would recommend doing this if you are deploying this to users via the Company Portal Click Next Enter your install command (e.g. 7z2002-x64.exe /S) Enter your uninstall command (e.g. \"C:\\Program Files\\7-Zip\\Uninstall.exe\" /S) Select your install behavior, if this is a machine wide installation you will need to select System, otherwise select User if this is installing to the user profile Select your desired restart behavior, Adding custom return codes if required Click Next Complete your OS Requirements, At a minimum you need to specify the Architecture (x86/x64) and the minimum OS Version (e.g. 1607/1703 etc.) Click Next For Detection rules, See the Detection Rules section below, Once complete click Next Add any dependent Intune Apps you may require, Click Next Assign the application to your desired group, just as a NOTE if you want to display the app in the company portal, it MUST be assigned to a group containing that user. Required Assignments will force the app to install, whereas Available will show this in the Company Portal. Click Next Click Create  That is your app finished and deploying, it is worth noting it may take 15/20 minutes to be available on the device, the device must also perform a sync to check for the app. Detection Rules\nDetection rules have 4 options, you can use a Custom Detection Script, Registry, File(Folder) and MSI, lets look at them in a little bit more detail.\nWhen you first reach the Detection Rule Screen you will have a single Drop-Down box with two options, Use a custom detection script and Manually configure detection rules. File, Registry and MSI are all available under the Manual option, it is worth noting that you can can mix and match these rules, however there are considered AND methods. If you are looking to do a AND/OR detection you will need to use a custom PowerShell Script.\nWe will dive into all of the options below.\nFile As you can see above using this detection method is fairly straight forward, however it can get a bit messy if you use the  Date Created/Modified options.\nLets put a rule together.\n Rule Type -  File Path - \"YourPath\" (e.g. C:\\Program Files\\7-Zip\\) File or Folder - \"YourFileFolder\" (e.g. 7z.exe) Detection Method - File or Folder Exists Associated with a 32-bit app on a 64-bit client, No.   Now that rule is very quick and simple, as mentioned you can use the date modified or created option, and that would look something like below.  Rule Type - File Path - \"YourPath\" (e.g. C:\\Program Files\\7-Zip\\) File or Folder - \"YourFileFolder\" (e.g. 7z.exe) Detection Method - Date Modified Operator, select the option that you wish to validate against (e.g. Equals, Greater than etc.) Select the date using the date picker and enter the time using the 12 hour format Associated with a 32-bit app on a 64-bit client, No.  Registry The registry option is fairly straight forward, and is the most likely option you are going to select if you are just installing a simple application and just want to check that the program itself exists. Again for the detection method you have various options, for this example we will just use Key Exists\n Rule Type -  Registry Key Path - \"Path to key\" (e.g. HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Windows/CurrentVersion/Uninstall/7-Zip) Value Name - \"Vaule Name\" (e.g. DisplayVersion) Detection Method - File or Folder Exists Associated with a 32-bit app on a 64-bit client, No.   MSI MSI detections are quick and easy if you are installing an MSI application, all you need is the GUID, for the 7-zip app this is not applicable however below is a basic example. You can also perform version checks on the MSI apps.\n Rule Type -  MSI MSI Product Code - \"Product GUID\" (e.g. {8C3A8923-0000-0000-0000-C82C1BE7294D}) MSI product version check - Yes Select your operator (e.g. Equals, Greater than etc.) Value - Product Version (e.g. 20.02)  Detection Script For me, this is the most favorable option, but I love to script :D. But that aside you can check multiple actions, the only thing you need to do is return any value other than Null for the detection to pass. For example the below script checks for the registry value and also that the file exists, if they do it will return a True value, else it will return nothing.\n# $7zReg = \u0026#34;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\7-Zip\u0026#34; $7zExe = \u0026#34;$env:ProgramFiles\\7-zip\\7z.exe\u0026#34; IF ((Get-ItemPropertyValue -Path $7zReg -Name DisplayVersion) -and (Test-Path $7zExe)) { $true } else {} You will need to have the file save and ready to be upload to Intune, The above is written in PowerShell so will need a .ps1 extension. To use this method follow the below steps.\n Rule format - Use custom detection script Script file - Upload yours using the blue folder icon Run Script as a 32-bit process on 64-bit clients - No (This is entirely your choice again but for this example it is not required) Enforce script signature check and run script silently - No  That covers the basics all of the detection methods, if you have any further questions please reach out or review the Microsoft Docs.  3rd Party/Community Tools \u0026amp; Blogs Here are some of the 3rd Party and Community Tools and Blogs that I have found useful and they may help you in you hour of need!!\nSyst \u0026amp; Deploy - Intune Win32 App Tool This is a great tool to create and extract/decode Win32 apps if you prefer a GUI to creating your intunewin files, this tool also has a feature to decode the packages you already have incase you loose the source files but have the intunewin file.\nIntune Win32app tool - Create and Extract Intunewin | Syst \u0026amp; Deploy (systanddeploy.com)\nOliver Kieselbach - How to decode Win32 App Packages This is a great guide and it can truly help pull you out of the gutter if you have lost all of your intunewin files, although its not straight forward to get them back (Not Oliver\u0026rsquo;s Fault) this guid provides you an in-depth guide on how to retrieve the intunewin packages. Truly worth a read and Kudos to Oliver for giving us this gift.\nHow to decode Intune Win32 App Packages – Modern IT – Cloud – Workplace (oliverkieselbach.com)\n","date":"5 January, 2021","image":["images/post/createwin32/FeaturedImage.png"],"permalink":"https://euc365.com/creating-intune-win32-apps/","tags":["Powershell","Intune","Application Deployment"],"title":"Creating Intune Win32 Apps"},{"categories":["Azure","Intune"],"contents":"Why do I need to find these? Welcome (Back) to another post about the graph API\u0026rsquo;s, This time it isn\u0026rsquo;t so much about rambling through documentation but about giving you a nice handy tip on your route to finding what API is been called when browsing in the Web Console.\nThe only things your are going to need for this will be an Azure AD Account with permissions to at least Read policies and a modern web browser, Yes really that\u0026rsquo;s it.\nTo test the API Paths you can use Postman or Microsoft Graph Explorer\nLets get started We are going to be using Azure AD groups for this but the same methods can be used across the board (Users, Intune etc.).\nLets start by opening your browser and browse to https://portal.azure.com, Once loaded if you hit the F12 key you will see the Developer Tools pane open. The next steps may vary based on your browser choice (I\u0026rsquo;m using Edge), If you click on the Network tab (shown below) you will notice it is blank.\nIf you navigate your way to Groups (Azure Active Directory \u0026gt; Groups) you will notice it starts to populate the left pane (As below)\nAs you can see there are some little cogs next to some of the rows, If you click on one of these you will see there will be data within them\u0026hellip; In this case I am going to use the one that is a darker grey in the above image. If you click on it in the right pane you will see what data is returned (As shown Below).\nIf you expand the value field you will see the data that it has returned and will notice that it matchs up to what your seeing on screen. Now if you hover over the field you will see what API call has been made (See Below).\nIf you right-click on the entry and click Copy\u0026gt;Copy Link Address and head over to the Graph Explorer and paste the URL into the URL box, you will receive the same results, albeit better formatted.\nTo Summarise Now this is only the start of the journey, you can use the knowledge you gain and already have to combine the two and make your own apps/scripts off of the back of it. This guide is just to help you find the API\u0026rsquo;s you need to be calling :D.\n","date":"5 October, 2020","image":["images/post/findapis/FeaturedImage.png"],"permalink":"https://euc365.com/finding-microsoft-graph-apis-from-the-web/","tags":["Azure","Intune","Microsoft Graph API"],"title":"Finding Microsoft Graph API's from the Web"},{"categories":["Powershell","Intune"],"contents":"Why backup App Protection Policies? Why would you need to back up something that runs in stored and hosted on Azure? Well there are numerous answers to this question really.\n If you make a change and you break something you can look back and analyse what it was You can make copies of the policy easily rather than having two windows side by side In case one is deleted… (Let’s hope this is never the case) To review the maturity of your policies (Lets say you started from ground zero and now have over 100 policy settings… Might be nice to review what you’ve done)  We also live in a world of change management and service improvement so there is always a need to make changes to policies and configurations. If you have or are moving from traditional group policy you will know that you can run an HTML report or a backup before you go ahead and make any changes. Well when using Intune there was no way to export or backup your profiles or policies from the console… I have seen people taking screenshots of the pages as a backup of the policies which is far from an ideal scenario.\nWhat if I told you there is a way you can back-up your configuration policies using the Microsoft Graph API?? Well it’s possible and it’s easier than you think.\nThis is part of a series of posts about backing up and importing policies and profiles, so if you feel like you\u0026rsquo;ve read this part before then you probably have.\nBack when I wrote my first post about these (HERE) the script just backed up the policies/profiles, however over time they have grown into scripts that you can also use to re-import these policies/profile.\nThis one is the Fourth in the series, where we will focus on App Protection Policies. Each one has brought its own challenges which are hopefully mitigated within the script, but if not you can always get in touch and let me know.\nThe Script You will notice that most of this (the authentication part and most of the param block at least) are the same as my other script\u0026hellip; But if its not broke why fix it? (Those famous last words!!!). Although this script does have an alternative run method, if you run it directly without the ClientID, ClientSecret and TenantID parameters it will install the Azure AD Powershell module and use a custom Function (Connect-AzAD_Token) to enable users to interact with a login Window if they do not wish to use Azure AD App Registrations with client secrets.\nThis script can be run from anywhere, as a user (If the using the command line parameters or if the AzureAD Module is installed already), as an Administrator or even as System. You could put this into an Automation Engine to do backups on a schedule if that is your desire but this would need to be done with an Azure App Registration.\nparam( [Parameter(DontShow = $true)] [string] $MsGraphVersion = \u0026#34;beta\u0026#34;, [Parameter(DontShow = $true)] [string] $MsGraphHost = \u0026#34;graph.microsoft.com\u0026#34;, #The AzureAD ClientID (Application ID) of your registered AzureAD App [string] $ClientID, #The Client Secret for your AzureAD App [string] $ClientSecret, #Your Azure Tenent ID [string] $TenantId, [Parameter()] [string] $OutputFolder = \u0026#34;.\\AppProtectionPolicyBackup\u0026#34;, [switch] $Import, [string] $ImportJSON )# FUNCTION Connect-AzAD_Token { Write-Host -ForegroundColor Cyan \u0026#34;Checking for AzureAD module...\u0026#34; $AADMod = Get-Module -Name \u0026#34;AzureAD\u0026#34; -ListAvailable if (!($AADMod)) { Write-Host -ForegroundColor Yellow \u0026#34;AzureAD PowerShell module not found, looking for AzureADPreview\u0026#34; $AADModPrev = Get-Module -Name \u0026#34;AzureADPreview\u0026#34; -ListAvailable #Check to see if the AzureAD Preview Module is insalled, If so se that as the AAD Module Else Insall the AzureAD Module IF ($AADModPrev) { $AADMod = Get-Module -Name \u0026#34;AzureADPreview\u0026#34; -ListAvailable } else { try { Write-Host -ForegroundColor Yello \u0026#34;AzureAD Preview is not installed...\u0026#34; Write-Host -ForegroundColor Cyan \u0026#34;Attempting to Install the AzureAD Powershell module...\u0026#34; Install-PackageProvider -Name NuGet -MinimumVersion 2.8.5.201 -Force -ErrorAction Stop | Out-Null Install-Module AzureAD -Force -ErrorAction Stop } catch { Write-Host -ForegroundColor Red \u0026#34;Failed to install the AzureAD PowerShell Module `n$($Error[0])\u0026#34; break } } } else { Write-Host -ForegroundColor Green \u0026#34;AzureAD Powershell Module Found\u0026#34; } $AADMod = ($AADMod | Select-Object -Unique | Sort-Object)[-1] $ADAL = Join-Path $AADMod.ModuleBase \u0026#34;Microsoft.IdentityModel.Clients.ActiveDirectory.dll\u0026#34; $ADALForms = Join-Path $AADMod.ModuleBase \u0026#34;Microsoft.IdentityModel.Clients.ActiveDirectory.Platform.dll\u0026#34; [System.Reflection.Assembly]::LoadFrom($ADAL) | Out-Null [System.Reflection.Assembly]::LoadFrom($ADALForms) | Out-Null $UserInfo = Connect-AzureAD # Microsoft Intune PowerShell Enterprise Application ID  $MIPEAClientID = \u0026#34;d1ddf0e4-d672-4dae-b554-9d5bdfd93547\u0026#34; # The redirectURI $RedirectURI = \u0026#34;urn:ietf:wg:oauth:2.0:oob\u0026#34; #The Authority to connect with (YOur Tenant) Write-Host -Foregroundcolor Cyan \u0026#34;Connected to Tenant: $($UserInfo.TenantID)\u0026#34; $Auth = \u0026#34;https://login.microsoftonline.com/$($UserInfo.TenantID)\u0026#34; try { $AuthContext = New-Object \u0026#34;Microsoft.IdentityModel.Clients.ActiveDirectory.AuthenticationContext\u0026#34; -ArgumentList $Auth # https://msdn.microsoft.com/en-us/library/azure/microsoft.identitymodel.clients.activedirectory.promptbehavior.aspx # Change the prompt behaviour to force credentials each time: Auto, Always, Never, RefreshSession $platformParameters = New-Object \u0026#34;Microsoft.IdentityModel.Clients.ActiveDirectory.PlatformParameters\u0026#34; -ArgumentList \u0026#34;Auto\u0026#34; $userId = New-Object \u0026#34;Microsoft.IdentityModel.Clients.ActiveDirectory.UserIdentifier\u0026#34; -ArgumentList ($UserInfo.Account, \u0026#34;OptionalDisplayableId\u0026#34;) $authResult = $AuthContext.AcquireTokenAsync((\u0026#34;https://\u0026#34; + $MSGraphHost),$MIPEAClientID,$RedirectURI,$platformParameters,$userId).Result # If the accesstoken is valid then create the authentication header if($authResult.AccessToken){ # Creating header for Authorization token $AADAccessToken = $authResult.AccessToken return $AADAccessToken } else { Write-Host -ForegroundColor Red \u0026#34;Authorization Access Token is null, please re-run authentication...\u0026#34; break } } catch { Write-Host -ForegroundColor Red $_.Exception.Message Write-Host -ForegroundColor Red $_.Exception.ItemName break } } # Web page used to help with getting the access token  #https://morgantechspace.com/2019/08/get-graph-api-access-token-using-client-id-and-client-secret.html  if (($ClientID) -and ($ClientSecret) -and ($TenantId) ) { #Create the body of the Authentication of the request for the OAuth Token $Body = @{client_id=$ClientID;client_secret=$ClientSecret;grant_type=\u0026#34;client_credentials\u0026#34;;scope=\u0026#34;https://$MSGraphHost/.default\u0026#34;;} #Get the OAuth Token  $OAuthReq = Invoke-RestMethod -Method Post -Uri \u0026#34;https://login.microsoftonline.com/$TenantId/oauth2/v2.0/token\u0026#34; -Body $Body #Set your access token as a variable $global:AccessToken = $OAuthReq.access_token } else { $global:AccessToken = Connect-AzAD_Token } IF (!($Import)) { $FormattedOutputFolder = \u0026#34;$OutputFolder\\$(Get-Date -Format yyyyMMdd_HH-mm-ss)\u0026#34; IF (!(Test-Path $FormattedOutputFolder)){ try { mkdir $FormattedOutputFolder -ErrorAction Stop | Out-Null } catch { Write-Host -ForegroundColor Red \u0026#34;Failed to create $FormattedOutputFolder\u0026#34; $Error[0] break } } Invoke-RestMethod -Method GET -Uri \u0026#34;https://$MSGraphHost/$MsGraphVersion/deviceAppManagement/managedAppPolicies\u0026#34; -Headers @{Authorization = \u0026#34;Bearer $AccessToken\u0026#34;} | Select-Object -ExpandProperty \u0026#34;Value\u0026#34; | %{ $_ | ConvertTo-Json | Out-File \u0026#34;$FormattedOutputFolder\\$($_.displayname).json\u0026#34; } }elseif ($Import) { IF($ImportJSON) { $JSON = Get-Content $ImportJSON | ConvertFrom-Json | Select-Object -Property * -ExcludeProperty Version,LastModifiedTime,CreatedDateTime,id | ConvertTo-Json Invoke-RestMethod -Method POST -Uri \u0026#34;https://$MSGraphHost/$MsGraphVersion/deviceAppManagement/managedAppPolicies\u0026#34; -Headers @{Authorization = \u0026#34;Bearer $AccessToken\u0026#34;} -Body $JSON -ContentType \u0026#34;application/json\u0026#34; } else { Write-Host -ForegroundColor RED \u0026#34;You must specify an a JSON file using the -ImportJSON parameter\u0026#34; } } The Pre-Reqs Azure AD App Registration To make the script work without user interaction from an automation engine you will need an Azure App Registration with the following permissions for the Microsoft Graph API;\nBacking Up App Protection Policies Only  DeviceManagementApps.Read.All (Application Permission)  Importing App Protection Policies  DeviceManagementApps.ReadWrite.All (Application Permission)  GRAPH API DOCUMENTATION If you are not executing the script directly, you will also need the Tenant ID and the account that the script will be running as will need permission to the Output folder for backups.\nIf your not sure how to create an Azure AD App Registration head over to one of my other posts by clicking HERE, Don\u0026rsquo;t forget to store your Client ID and Secret securely and also have it to hand for the rest of the post :D.\nExecuting the Script Unattended with an Azure AD App Registration You can run this script directly from a PowerShell console, using Task Scheduler or using a 3rd party automation product that supports Powershell.\nThe main thing we will go through here is just the parameters and then putting them all together from the command line, it\u0026rsquo;s really that simple.\nFor Backup Only  Client ID: This is the Client ID for your Azure AD App ClientSecret: The Client Secret for the Azure AD App TenantID: Your Azure Tenant ID OutputFolder: Your desired Output folder  `./Backup_Import_AppProtectionPolicies.ps1 -ClientID \"\" -ClientSecret \"\" -TenantID \"\" -OutputFolder \"./YourServerBackups/AppProtectionPolicies\"` For Importing Policies  Client ID: This is the Client ID for your Azure AD App ClientSecret: The Client Secret for the Azure AD App TenantID: Your Azure Tenant ID Import: This is a switch parameter which states if your intention is to import or not ImportJSON: the path to your JSON file.  You will finally end up with something like this; ./Backup_Import_AppProtectionPolicies.ps1 -ClientID \u0026quot;\u0026quot; -ClientSecret \u0026quot;\u0026quot; -TenantID \u0026quot;\u0026quot; -Import -ImportJSON \u0026quot;./YourServerBackups/AppProtectionPolicies/ImportMe.JSON\u0026quot;\nDirect Execution If you launch the script without the Client ID, Secret and Tenant ID you will be prompted with a Microsoft Logon Window similar to the below.\nOnce you login the script will continue to run and then output the configuration files in the same way it would using the App Registration. You will need an account with permissions to be able to read (for backups only) or Read and Write the App Protection Policies. However the likelihood is that if you are looking at this guide you are probably an Intune Service Administrator or Global Administrator on your Tenant.\nWhen you run it directly without any switches the script will prompt you to log in and it would only perform a backup of your profiles and output the configurations to the the folder you are executing it from.\nIf you add the -OutputFolder parameter you can change the destination of the base output folder. However if you are wishing to use the script to Import policies you can add the -Import and -ImportJSON parameters, If you specify the -Import  parameter you must also specify the -ImportJSON parameter with a path to the JSON file (e.g. C:/ImportMe.json) otherwise the script will display a message that you did not specify the -ImportJSON Parameter.\nYou will notice that when you run the script, if the folder does not exist it will create it. It also put its into a dated folder in the yyyyMMdd_HH-mm-ss format leaving you with something like 20200901_16_05_36\nSummary This can also be useful if you are wanting to make a copy of your policies to assign to a test machine. All you will need to do is backup your current policies and amend the JSON file, If you find the displayName field in the JSON file and amend it and save the file you will be able to re-import this the same settings. All you then need to do is assign it.\nI have tested this myself at the time of writing the post but if you come across any information you think may be wrong then please leave a comment or e-mail me on david@euc365.com.\nI hope this is useful for your needs.\n","date":"18 September, 2020","image":["images/post/backupappprotection/FeaturedImage.png"],"permalink":"https://euc365.com/backup-and-import-app-protection-policies/","tags":["Azure","Azure AD","Azure App Registrations","Powershell","Intune","Microsoft Graph API","App Protection"],"title":"Backup and Import App Protection Policies"},{"categories":["Azure","Powershell","Intune"],"contents":"Why backup Conditional Access Policies? Why would you need to back up something that runs in stored and hosted on Azure? Well there are numerous answers to this question really.\n If you make a change and you break something you can look back and analyse what it was You can make copies of the policy easily rather than having two windows side by side In case one is deleted… (Let’s hope this is never the case) To review the maturity of your policies (Lets say you started from ground zero and now have over 100 policy settings… Might be nice to review what you’ve done)  We also live in a world of change management and service improvement so there is always a need to make changes to policies and configurations. If you have or are moving from traditional group policy you will know that you can run an HTML report or a backup before you go ahead and make any changes. Well when using Intune there was no way to export or backup your profiles or policies from the console… I have seen people taking screenshots of the pages as a backup of the policies which is far from an ideal scenario.\nWhat if I told you there is a way you can back-up your configuration policies using the Microsoft Graph API?? Well it’s possible and it’s easier than you think.\nThis is part of a series of posts about backing up and importing policies and profiles, so if you feel like you\u0026rsquo;ve read this part before then you probably have.\nBack when I wrote my first post about these (HERE) the script just backed up the policies/profiles, however over time they have grown into scripts that you can also use to re-import these policies/profile.\nThis one is the Third in the series, where we will focus on Conditional Access Policies.Each one has brought its own challenges which are hopefully mitigated within the script, but if not you can always get in touch and let me know.\nThe Script You will notice that most of this (the authentication part and most of the param block at least) are the same as my other script\u0026hellip; But if its not broke why fix it? (Those famous last words!!!). Although this script does have an alternative run method, if you run it directly without the ClientID, ClientSecret and TenantID parameters it will install the Azure AD Powershell module and use a custom Function (Connect-AzAD_Token) to enable users to interact with a login Window if they do not wish to use Azure AD App Registrations with client secrets.\nThis Conditional Access script WILL ALWAYS REQUIRE A CUSTOM APP REGISTRATION. I\u0026rsquo;ve not put that in bold to be shouty but just to highlight it and stand out, as I was going around in circles for a couple of days trying to figure out why this one would not work!!!.\nThis script can be run from anywhere, as a user (If the using the command line parameters or if the AzureAD Module is installed already), as an Administrator or even as System. You could put this into an Automation Engine to do backups on a schedule if that is your desire but this would need to be done with an Azure App Registration.\nparam( [Parameter(DontShow = $true)] [string] $MsGraphVersion = \u0026#34;beta\u0026#34;, [Parameter(DontShow = $true)] [string] $MsGraphHost = \u0026#34;graph.microsoft.com\u0026#34;, #The AzureAD ClientID (Application ID) of your registered AzureAD App with Delegate permissions [string] $DelegateClientID, #The AzureAD ClientID (Application ID) of your registered AzureAD App [string] $ClientID, #The Client Secret for your AzureAD App [string] $ClientSecret, #Your Azure Tenent ID [string] $TenantId, [Parameter()] [string] $OutputFolder = \u0026#34;.ConditionalAccessPolicyBackup\u0026#34;, [switch] $Import, [string] $ImportJSON )# FUNCTION Connect-AzAD_Token ($DelegateID){ Write-Host -ForegroundColor Cyan \u0026#34;Checking for AzureAD module...\u0026#34; $AADMod = Get-Module -Name \u0026#34;AzureAD\u0026#34; -ListAvailable if (!($AADMod)) { Write-Host -ForegroundColor Yellow \u0026#34;AzureAD PowerShell module not found, looking for AzureADPreview\u0026#34; $AADModPrev = Get-Module -Name \u0026#34;AzureADPreview\u0026#34; -ListAvailable #Check to see if the AzureAD Preview Module is insalled, If so se that as the AAD Module Else Insall the AzureAD Module IF ($AADModPrev) { $AADMod = Get-Module -Name \u0026#34;AzureADPreview\u0026#34; -ListAvailable } else { try { Write-Host -ForegroundColor Yello \u0026#34;AzureAD Preview is not installed...\u0026#34; Write-Host -ForegroundColor Cyan \u0026#34;Attempting to Install the AzureAD Powershell module...\u0026#34; Install-PackageProvider -Name NuGet -MinimumVersion 2.8.5.201 -Force -ErrorAction Stop | Out-Null Install-Module AzureAD -Force -ErrorAction Stop } catch { Write-Host -ForegroundColor Red \u0026#34;Failed to install the AzureAD PowerShell Module `n$($Error[0])\u0026#34; break } } } else { Write-Host -ForegroundColor Green \u0026#34;AzureAD Powershell Module Found\u0026#34; } $AADMod = ($AADMod | Select-Object -Unique | Sort-Object)[-1] $ADAL = Join-Path $AADMod.ModuleBase \u0026#34;Microsoft.IdentityModel.Clients.ActiveDirectory.dll\u0026#34; $ADALForms = Join-Path $AADMod.ModuleBase \u0026#34;Microsoft.IdentityModel.Clients.ActiveDirectory.Platform.dll\u0026#34; [System.Reflection.Assembly]::LoadFrom($ADAL) | Out-Null [System.Reflection.Assembly]::LoadFrom($ADALForms) | Out-Null $UserInfo = Connect-AzureAD # Your Azure Application ID  $MIPEAClientID = $DelegateID # The redirectURI $RedirectURI = \u0026#34;urn:ietf:wg:oauth:2.0:oob\u0026#34; #The Authority to connect with (YOur Tenant) Write-Host -Foregroundcolor Cyan \u0026#34;Connected to Tenant: $($UserInfo.TenantID)\u0026#34; $Auth = \u0026#34;https://login.microsoftonline.com/$($UserInfo.TenantID)\u0026#34; try { $AuthContext = New-Object \u0026#34;Microsoft.IdentityModel.Clients.ActiveDirectory.AuthenticationContext\u0026#34; -ArgumentList $Auth # https://msdn.microsoft.com/en-us/library/azure/microsoft.identitymodel.clients.activedirectory.promptbehavior.aspx # Change the prompt behaviour to force credentials each time: Auto, Always, Never, RefreshSession $platformParameters = New-Object \u0026#34;Microsoft.IdentityModel.Clients.ActiveDirectory.PlatformParameters\u0026#34; -ArgumentList \u0026#34;Auto\u0026#34; $userId = New-Object \u0026#34;Microsoft.IdentityModel.Clients.ActiveDirectory.UserIdentifier\u0026#34; -ArgumentList ($UserInfo.Account, \u0026#34;OptionalDisplayableId\u0026#34;) $authResult = $AuthContext.AcquireTokenAsync((\u0026#34;https://\u0026#34; + $MSGraphHost),$MIPEAClientID,$RedirectURI,$platformParameters,$userId).Result # If the accesstoken is valid then create the authentication header if($authResult.AccessToken){ # Creating header for Authorization token $AADAccessToken = $authResult.AccessToken return $AADAccessToken } else { Write-Host -ForegroundColor Red \u0026#34;Authorization Access Token is null, please re-run authentication...\u0026#34; break } } catch { Write-Host -ForegroundColor Red $_.Exception.Message Write-Host -ForegroundColor Red $_.Exception.ItemName break } } # Web page used to help with getting the access token  #https://morgantechspace.com/2019/08/get-graph-api-access-token-using-client-id-and-client-secret.html  if (($ClientID) -and ($ClientSecret) -and ($TenantId) ) { #Create the body of the Authentication of the request for the OAuth Token $Body = @{client_id=$ClientID;client_secret=$ClientSecret;grant_type=\u0026#34;client_credentials\u0026#34;;scope=\u0026#34;https://$MSGraphHost/.default\u0026#34;;} #Get the OAuth Token  $OAuthReq = Invoke-RestMethod -Method Post -Uri \u0026#34;https://login.microsoftonline.com/$TenantId/oauth2/v2.0/token\u0026#34; -Body $Body #Set your access token as a variable $global:AccessToken = $OAuthReq.access_token } else { if (!($DelegateClientID)) { Write-Host -ForegroundColor Red \u0026#34;You must specify a clientID which has the correct delegate permissions and URI Re-write configuration \u0026#34; break } $global:AccessToken = Connect-AzAD_Token -DelegateID $DelegateClientID } IF (!($Import)) { $FormattedOutputFolder = \u0026#34;$OutputFolder$(Get-Date -Format yyyyMMdd_HH-mm-ss)\u0026#34; IF (!(Test-Path $FormattedOutputFolder)){ try { mkdir $FormattedOutputFolder -ErrorAction Stop | Out-Null } catch { Write-Host -ForegroundColor Red \u0026#34;Failed to create $FormattedOutputFolder\u0026#34; $Error[0] break } } Invoke-RestMethod -Method GET -Uri \u0026#34;https://$MSGraphHost/$MsGraphVersion/identity/conditionalAccess/policies\u0026#34; -Headers @{Authorization = \u0026#34;Bearer $AccessToken\u0026#34;} -ContentType \u0026#34;application/json\u0026#34; | Select-Object -ExpandProperty \u0026#34;Value\u0026#34; | %{ $_ | ConvertTo-Json -Depth 10 | Out-File \u0026#34;$FormattedOutputFolder$($_.displayname).json\u0026#34; } }elseif ($Import) { $JSON = Get-Content $ImportJSON | ConvertFrom-Json | Select-Object -Property * -ExcludeProperty Version,modifiedDateTime,CreatedDateTime,id,sessionControls | ConvertTo-Json -Depth 10 Invoke-RestMethod -Method POST -Uri \u0026#34;https://$MSGraphHost/$MsGraphVersion/identity/conditionalAccess/policies\u0026#34; -Headers @{Authorization = \u0026#34;Bearer $AccessToken\u0026#34;} -Body $JSON -ContentType \u0026#34;application/json\u0026#34; } The Pre-Reqs Azure AD App Registration To make the script work you will need an Azure App Registration with the following permissions for the Microsoft Graph API;\nBacking Up Conditional Access Policies Only For Direct Execution (Using the login box) you will need;\n Policy.Read.All (Delegate Permission)  Using the ClientID, ClientSecret and TenantID (Unattended) you will need;  Policy.Read.All (Application Permission)  Importing Conditional Access Policies For Direct Execution (Using the login box) you will need;\n Policy.Read.All (Delegate Permission) Policy.ReadWrite.ConditionalAccess (Delegate Permission) Application.Read.All (Delegate Permission)  Using the ClientID, ClientSecret and TenantID (Unattended) you will need;  Policy.Read.All (Application Permission) Policy.ReadWrite.ConditionalAccess (ApplicationPermission) Application.Read.All (Application Permission)  GRAPH API DOCUMENTATION If you are not executing the script directly, you will also need the Tenant ID and the account that the script will be running as will need permission to the Output folder for backups.\nIf your not sure how to create an Azure AD App Registration head over to one of my other posts by clicking HERE, Don\u0026rsquo;t forget to store your Client ID and Secret securely and also have it to hand for the rest of the post :D.\nRedirect URI For this one, there is a little bit more to do with the Azure AD Application. We are going to need to add a re-write URI for Authentication when using the Login Prompt (Delegated Permissions). If you do not have a Redirect URI or it is not the correct one you will recieve an error like below.\nWe need to add urn:ietf:wg:oauth:2.0:oob as a redirect URI for the application. To do so follow the below steps;\n Browse to your Azure AD Application Registration Click on Authntication located in the left pane Click Add a Platform Click Mobile and Desktop applications Copy and paste urn:ietf:wg:oauth:2.0:oob into the Redirect URI field Click Configure  This will enable the Authentication box to work with Conditional Access. Unfortunately I was unable to add these Permissions to the Microsoft Intune PowerShell Enterprise Application so I could have left this as a default ClientID for that in each tenant. Executing the Script Unattended with an Azure AD App Registration You can run this script directly from a PowerShell console, using Task Scheduler or using a 3rd party automation product that supports Powershell.\nThe main thing we will go through here is just the parameters and then putting them all together from the command line, it\u0026rsquo;s really that simple.\nFor Backup Only  Client ID: This is the Client ID for your Azure AD App ClientSecret: The Client Secret for the Azure AD App TenantID: Your Azure Tenant ID OutputFolder: Your desired Output folder  ./Backup_Import_ConditionalAccessPolicies.ps1 -ClientID \u0026quot;\u0026quot; -ClientSecret \u0026quot;\u0026quot; -TenantID \u0026quot;\u0026quot; -OutputFolder \u0026quot;./YourServerBackups/ConditionalAccessPolicies\u0026quot;\nFor Importing Policies  Client ID: This is the Client ID for your Azure AD App ClientSecret: The Client Secret for the Azure AD App TenantID: Your Azure Tenant ID Import: This is a switch parameter which states if your intention is to import or not ImportJSON: the path to your JSON file.  You will finally end up with something like this; ./Backup_Import_ConditionalAccessPolicies.ps1 -ClientID \u0026quot;\u0026quot; -ClientSecret \u0026quot;\u0026quot; -TenantID \u0026quot;\u0026quot; -Import -ImportJSON \u0026quot;./YourServerBackups/ConditionalAccessPolicies/ImportMe.JSON\u0026quot;\nDirect Execution (With your Azure AD App Registration) There is a slight change here from my previous posts as mentioned above in the Script section we need an Azure AD App registration for this one in any case. The fundamental difference here though is the permission type (Delegate) and it does not require a Secret and TenantID.\nIf you launch the script without the required -DelegateClientID parameter you will be prompted with a message saying you need to launch it with one. So for this direct execution you will need to launch the script like below;\nFor Backup ./Backup_Import_ConditionalAccessPolicies.ps1 -DelegateClientID \u0026quot;\u0026quot;\nFor Import ./Backup_Import_ConditionalAccessPolicies.ps1 -DelegateClientID \u0026quot;\u0026quot; -Import -ImportJSON \u0026quot;./YourServerBackups/ConditionalAccessPolicies/ImportMe.JSON\u0026quot;\nYou will then be prompted with a Microsoft Logon Window similar to the below.\nOnce you login the script will continue to run and then output the policy files in the same way it would using the App Registration.\nIf you add the -OutputFolder parameter you can change the destination of the base output folder. However if you are wishing to use the script to Import policies you can add the -Import  and -ImportJSON parameters, If you specify the -Import  parameter you must also specify the -ImportJSON parameter with a path to the JSON file (e.g. C:/ImportMe.json) otherwise the script will display a message that you did not specify the -ImportJSON Parameter.\nYou will notice that when you run the script, if the folder does not exist it will create it. It also put its into a dated folder in the yyyyMMdd_HH-mm-ss format leaving you with something like 20200914_11-52-22\nSummary This can also be useful if you are wanting to make a copy of your policies to assign to a test machine. All you will need to do is backup your current policies and amend the JSON file, If you find the displayName field in the JSON file and amend it and save the file you will be able to re-import this the same settings. All you then need to do is assign it.\nI have tested this myself at the time of writing the post but if you come across any information you think may be wrong then please leave a comment or e-mail me on david@euc365.com.\nI hope this is useful for your needs.\n","date":"14 September, 2020","image":["images/post/backupconditionalaccess/FeaturedImage.png"],"permalink":"https://euc365.com/backup-and-import-conditional-access-policies/","tags":["Azure","Azure AD","Azure App Registrations","Powershell","Intune","Microsoft Graph API","Conditional Access"],"title":"Backup and Import Conditional Access Policies"},{"categories":["Powershell","Intune"],"contents":"Why backup Compliance Policies Why would you need to back up something that runs in stored and hosted on Azure? Well there are numerous answers to this question really.\n If you make a change and you break something you can look back and analyse what it was You can make copies of the policy easily rather than having two windows side by side In case one is deleted… (Let’s hope this is never the case) To review the maturity of your policies (Lets say you started from ground zero and now have over 100 policy settings… Might be nice to review what you’ve done)  We also live in a world of change management and service improvement so there is always a need to make changes to policies and configurations. If you have or are moving from traditional group policy you will know that you can run an HTML report or a backup before you go ahead and make any changes. Well when using Intune there was no way to export or backup your profiles or policies from the console… I have seen people taking screenshots of the pages as a backup of the policies which is far from an ideal scenario.\nWhat if I told you there is a way you can back-up your configuration policies using the Microsoft Graph API?? Well it’s possible and it’s easier than you think.\nThis is part of a series of posts about backing up and importing policies and profiles, so if you feel like you’ve read this part before then you probably have.\nBack when I wrote my first post about these (HERE) the script just backed up the policies/profiles, however over time they have grown into scripts that you can also use to re-import these policies/profile.\nThis one is the Second in the series, where we will focus on Compliance Policies. Each one has brought its own challenges which are hopefully mitigated within the script, but if not you can always get in touch and let me know.\nThe Script You will notice that most of this (the authentication part and most of the param block at least) are the same as my other script… But if its not broke why fix it? (Those famous last words!!!). Although this script does have an alternative run method, if you run it directly without the ClientID, ClientSecret and TenantID parameters it will install the Azure AD Powershell module and use a custom Function (Connect-AzAD_Token) to enable users to interact with a login Window if they do not wish to use Azure AD App Registrations with client secrets.\nThis script can be run from anywhere, as a user (If the using the command line parameters or if the AzureAD Module is installed already), as an Administrator or even as System. You could put this into an Automation Engine to do backups on a schedule if that is your desire but this would need to be done with an Azure App Registration.\nparam( [Parameter(DontShow = $true)] [string] $MsGraphVersion = \u0026#34;beta\u0026#34;, [Parameter(DontShow = $true)] [string] $MsGraphHost = \u0026#34;graph.microsoft.com\u0026#34;, #The AzureAD ClientID (Application ID) of your registered AzureAD App [string] $ClientID, #The Client Secret for your AzureAD App [string] $ClientSecret, #Your Azure Tenent ID [string] $TenantId, [Parameter()] [string] $OutputFolder = \u0026#34;./CompliancePolicyBackup\u0026#34;, [switch] $Import, [string] $ImportJSON )# FUNCTION Connect-AzAD_Token { Write-Host -ForegroundColor Cyan \u0026#34;Checking for AzureAD module...\u0026#34; $AADMod = Get-Module -Name \u0026#34;AzureAD\u0026#34; -ListAvailable if (!($AADMod)) { Write-Host -ForegroundColor Yellow \u0026#34;AzureAD PowerShell module not found, looking for AzureADPreview\u0026#34; $AADModPrev = Get-Module -Name \u0026#34;AzureADPreview\u0026#34; -ListAvailable #Check to see if the AzureAD Preview Module is insalled, If so se that as the AAD Module Else Insall the AzureAD Module IF ($AADModPrev) { $AADMod = Get-Module -Name \u0026#34;AzureADPreview\u0026#34; -ListAvailable } else { try { Write-Host -ForegroundColor Yello \u0026#34;AzureAD Preview is not installed...\u0026#34; Write-Host -ForegroundColor Cyan \u0026#34;Attempting to Install the AzureAD Powershell module...\u0026#34; Install-PackageProvider -Name NuGet -MinimumVersion 2.8.5.201 -Force -ErrorAction Stop | Out-Null Install-Module AzureAD -Force -ErrorAction Stop } catch { Write-Host -ForegroundColor Red \u0026#34;Failed to install the AzureAD PowerShell Module `n$($Error[0])\u0026#34; break } } } else { Write-Host -ForegroundColor Green \u0026#34;AzureAD Powershell Module Found\u0026#34; } $AADMod = ($AADMod | Select-Object -Unique | Sort-Object)[-1] $ADAL = Join-Path $AADMod.ModuleBase \u0026#34;Microsoft.IdentityModel.Clients.ActiveDirectory.dll\u0026#34; $ADALForms = Join-Path $AADMod.ModuleBase \u0026#34;Microsoft.IdentityModel.Clients.ActiveDirectory.Platform.dll\u0026#34; [System.Reflection.Assembly]::LoadFrom($ADAL) | Out-Null [System.Reflection.Assembly]::LoadFrom($ADALForms) | Out-Null $UserInfo = Connect-AzureAD # Microsoft Intune PowerShell Enterprise Application ID  $MIPEAClientID = \u0026#34;d1ddf0e4-d672-4dae-b554-9d5bdfd93547\u0026#34; # The redirectURI $RedirectURI = \u0026#34;urn:ietf:wg:oauth:2.0:oob\u0026#34; #The Authority to connect with (YOur Tenant) Write-Host -Foregroundcolor Cyan \u0026#34;Connected to Tenant: $($UserInfo.TenantID)\u0026#34; $Auth = \u0026#34;https://login.microsoftonline.com/$($UserInfo.TenantID)\u0026#34; try { $AuthContext = New-Object \u0026#34;Microsoft.IdentityModel.Clients.ActiveDirectory.AuthenticationContext\u0026#34; -ArgumentList $Auth # https://msdn.microsoft.com/en-us/library/azure/microsoft.identitymodel.clients.activedirectory.promptbehavior.aspx # Change the prompt behaviour to force credentials each time: Auto, Always, Never, RefreshSession $platformParameters = New-Object \u0026#34;Microsoft.IdentityModel.Clients.ActiveDirectory.PlatformParameters\u0026#34; -ArgumentList \u0026#34;Auto\u0026#34; $userId = New-Object \u0026#34;Microsoft.IdentityModel.Clients.ActiveDirectory.UserIdentifier\u0026#34; -ArgumentList ($UserInfo.Account, \u0026#34;OptionalDisplayableId\u0026#34;) $authResult = $AuthContext.AcquireTokenAsync((\u0026#34;https://\u0026#34; + $MSGraphHost),$MIPEAClientID,$RedirectURI,$platformParameters,$userId).Result # If the accesstoken is valid then create the authentication header if($authResult.AccessToken){ # Creating header for Authorization token $AADAccessToken = $authResult.AccessToken return $AADAccessToken } else { Write-Host -ForegroundColor Red \u0026#34;Authorization Access Token is null, please re-run authentication...\u0026#34; break } } catch { Write-Host -ForegroundColor Red $_.Exception.Message Write-Host -ForegroundColor Red $_.Exception.ItemName break } } # Web page used to help with getting the access token  #https://morgantechspace.com/2019/08/get-graph-api-access-token-using-client-id-and-client-secret.html  if (($ClientID) -and ($ClientSecret) -and ($TenantId) ) { #Create the body of the Authentication of the request for the OAuth Token $Body = @{client_id=$ClientID;client_secret=$ClientSecret;grant_type=\u0026#34;client_credentials\u0026#34;;scope=\u0026#34;https://$MSGraphHost/.default\u0026#34;;} #Get the OAuth Token  $OAuthReq = Invoke-RestMethod -Method Post -Uri \u0026#34;https://login.microsoftonline.com/$TenantId/oauth2/v2.0/token\u0026#34; -Body $Body #Set your access token as a variable $global:AccessToken = $OAuthReq.access_token } else { $global:AccessToken = Connect-AzAD_Token } IF (!($Import)) { $FormattedOutputFolder = \u0026#34;$OutputFolder$(Get-Date -Format yyyyMMdd_HH-mm-ss)\u0026#34; IF (!(Test-Path $FormattedOutputFolder)){ try { mkdir $FormattedOutputFolder -ErrorAction Stop | Out-Null } catch { Write-Host -ForegroundColor Red \u0026#34;Failed to create $FormattedOutputFolder\u0026#34; $Error[0] break } } Invoke-RestMethod -Method GET -Uri \u0026#34;https://$MSGraphHost/$MsGraphVersion/deviceManagement/deviceCompliancePolicies\u0026#34; -Headers @{Authorization = \u0026#34;Bearer $AccessToken\u0026#34;} | Select-Object -ExpandProperty \u0026#34;Value\u0026#34; | %{ $_ | ConvertTo-Json | Out-File \u0026#34;$FormattedOutputFolder$($_.displayname).json\u0026#34; } }elseif ($Import) { IF ($ImportJSON){ #$JSON = GET-Content $ImportJSON $JSON = Get-Content $ImportJSON | ConvertFrom-Json | Select-Object -Property * -ExcludeProperty Version,LastModifiedTime,CreatedDateTime,id | ConvertTo-Json $SAFRule = \u0026#39;\u0026#34;scheduledActionsForRule\u0026#34;: [ { \u0026#34;ruleName\u0026#34;: \u0026#34;PasswordRequired\u0026#34;, \u0026#34;scheduledActionConfigurations\u0026#34;: [ { \u0026#34;actionType\u0026#34;: \u0026#34;block\u0026#34;, \u0026#34;gracePeriodHours\u0026#34;: 0, \u0026#34;notificationTemplateId\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;notificationMessageCCList\u0026#34;: [ ] } ] } ]\u0026#39; $JSON = $Json.trimend(\u0026#34;}\u0026#34;) + \u0026#34;,\u0026#34; + \u0026#34;`r`n\u0026#34; + $SAFRule + \u0026#34;`r`n\u0026#34; + \u0026#34;}\u0026#34; Invoke-RestMethod -Method POST -Uri \u0026#34;https://$MSGraphHost/$MsGraphVersion/deviceManagement/deviceCompliancePolicies\u0026#34; -Headers @{Authorization = \u0026#34;Bearer $AccessToken\u0026#34;} -Body $JSON -ContentType \u0026#34;application/json\u0026#34; } else { Write-Host -ForegroundColor RED \u0026#34;You must specify an a JSON file using the -ImportJSON parameter\u0026#34; } } The Pre-Reqs With an Azure AD App Registration To make the script work you will need an Azure App Registration with the following permissions for the Microsoft Graph API;\nFor backing up the Compliance Policies you will need the DeviceManagementConfiguration.Read.All permission (NOTE: This will need to be Application permissions if you are using the App Registration).\nIf you wish to import Compliance Policies you will need the DeviceManagementConfiguration.ReadWrite.All permission.\nGRAPH API DOCUMENTATION\nYou will also need the Tenant ID and the account that the script will be running as will need permission to the Output folder.\nIf your not sure how to create an Azure AD App Registration head over to one of my other posts by clicking HERE, Don\u0026rsquo;t forget to store your Client ID and Secret securely and also have it to hand for the rest of the post :D.\nExecuting the Script With an Azure AD App Registration You can run this script directly from a PowerShell console, using Task Scheduler or using a 3rd party automation product that supports Powershell.\nThe main thing we will go through here is just the parameters and then putting them all together from the command line, it\u0026rsquo;s really that simple.\nFor Backup Only  Client ID: This is the Client ID for your Azure AD App ClientSecret: The Client Secret for the Azure AD App TenantID: Your Azure Tenant ID OutputFolder: Your desired Output folder  ./Backup_Import_CompliancePolicies.ps1 -ClientID \"\" -ClientSecret \"\" -TenantID \"\" -OutputFolder \"./YourServerBackups/CompliancePolicies\" For Importing Policies  Client ID: This is the Client ID for your Azure AD App ClientSecret: The Client Secret for the Azure AD App TenantID: Your Azure Tenant ID Import: This is a switch parameter which states if your intention is to import or not ImportJSON: the path to your JSON file.  You will finally end up with something like this; ./Backup_Import_CompliancePolicies.ps1 -ClientID \u0026quot;\u0026quot; -ClientSecret \u0026quot;\u0026quot; -TenantID \u0026quot;\u0026quot; -Import -ImportJSON \u0026ldquo;./YourServerBackups/CompliancePolicies/ImportMe.JSON\u0026rdquo;\nDirect Execution If you launch the script without the Client ID, Secret and Tenant ID you will be prompted with a Microsoft Logon Window similar to the below. Once you login the script will continue to run and then output the configuration files in the same way it would using the App Registration. You will need an account with permissions to be able to read (for backups only) or Read and Write the Compliance Policies. However the likelihood is that if you are looking at this guide you are probably an Intune Service Administrator or Global Administrator on your Tenant.\nWhen you run it directly without any switches the script will prompt you to log in and it would only perform a backup of your profiles and output the configurations to the the folder you are executing it from.\nIf you add the -OutputFolder parameter you can change the destination of the base output folder. However if you are wishing to use the script to Import policies you can add the -Import  and -ImportJSON parameters, If you specify the -Import  parameter you must also specify the -ImportJSON parameter with a path to the JSON file (e.g. C:/ImportMe.json) otherwise the script will display a message that you did not specify the -ImportJSON Parameter.\nYou will notice that when you run the script, if the folder does not exist it will create it. It also put its into a dated folder in the yyyyMMdd_HH-mm-ss format leaving you with something like 20200901_16_05_36\nSummary This can also be useful if you are wanting to make a copy of your policies to assign to a test machine. All you will need to do is backup your current policies and amend the JSON file, If you find the displayName field in the JSON file and amend it and save the file you will be able to re-import this the same settings. All you then need to do is assign it.\nI have tested this myself at the time of writing the post but if you come across any information you think may be wrong then please leave a comment or e-mail me on david@euc365.com.\nI hope this is useful for your needs.\n","date":"9 September, 2020","image":["images/post/backupcompliencepolicy/FeaturedImage.png"],"permalink":"https://euc365.com/backup-and-import-intune-compliance-policies/","tags":["Azure App Registrations","Powershell","Intune","Microsoft Graph API","Compliance"],"title":"Backup and Import Intune Compliance Policies"},{"categories":["Powershell","Intune"],"contents":"Why backup Device Configuration Profiles? Why would you need to back up something that runs in stored and hosted on Azure? Well there are numerous answers to this question really.\n If you make a change and you break something you can look back and analyse what it was You can make copies of the policy easily rather than having two windows side by side In case one is deleted... (Let's hope this is never the case) To review the maturity of your policies (Lets say you started from ground zero and now have over 100 policy settings... Might be nice to review what you've done)  We also live in a world of change management and service improvement so there is always a need to make changes to policies and configurations. If you have or 9are moving from traditional group policy you will know that you can run an HTML report or a backup before you go ahead and make any changes. Well when using Intune there was no way to export or backup your profiles or policies from the console\u0026hellip; I have seen people taking screenshots of the pages as a backup of the policies which is far from an ideal scenario.\nWhat if I told you there is a way you can back-up your configuration policies using the Microsoft Graph API?? Well it\u0026rsquo;s possible and it\u0026rsquo;s easier than you think.\nThis is the first of a series of guides on how to backup and import different types of policies and profiles using the API. This one will be focusing on Device Configuration Profiles.\nThe Script You will notice that most of this (the authentication part and most of the param block at least) are the same as my other script\u0026hellip; But if its not broke why fix it? (Those famous last words!!!). Although this script does have an alternative run method, if you run it directly without the ClientID, ClientSecret and TenantID parameters it will install the Azure AD Powershell module and use a custom Function Connect-AzAD_Token to enable users to interact with a login Window if they do not wish to use Azure AD App Registrations with client secrets.\nThis script can be run from anywhere, as a user, as an Admin or even as System. You could put this into an Automation Engine to do backups on a schedule if that is your desire.\nparam( [Parameter(DontShow = $true)] [string] $MsGraphVersion = \u0026#34;beta\u0026#34;, [Parameter(DontShow = $true)] [string] $MsGraphHost = \u0026#34;graph.microsoft.com\u0026#34;, #The AzureAD ClientID (Application ID) of your registered AzureAD App [string] $ClientID, #The Client Secret for your AzureAD App [string] $ClientSecret, #Your Azure Tenent ID [string] $TenantId, [Parameter()] [string] $OutputFolder = \u0026#34;.\\ConfigurationProfileBackup\u0026#34;, [switch] $Import, [string] $importJSON ) FUNCTION Connect-AzAD_Token { Write-Host -ForegroundColor Cyan \u0026#34;Checking for AzureAD module...\u0026#34; $AADMod = Get-Module -Name \u0026#34;AzureAD\u0026#34; -ListAvailable if (!($AADMod)) { Write-Host -ForegroundColor Yellow \u0026#34;AzureAD PowerShell module not found, looking for AzureADPreview\u0026#34; $AADModPrev = Get-Module -Name \u0026#34;AzureADPreview\u0026#34; -ListAvailable #Check to see if the AzureAD Preview Module is insalled, If so se that as the AAD Module Else Insall the AzureAD Module IF ($AADModPrev) { $AADMod = Get-Module -Name \u0026#34;AzureADPreview\u0026#34; -ListAvailable } else { try { Write-Host -ForegroundColor Yello \u0026#34;AzureAD Preview is not installed...\u0026#34; Write-Host -ForegroundColor Cyan \u0026#34;Attempting to Install the AzureAD Powershell module...\u0026#34; Install-PackageProvider -Name NuGet -MinimumVersion 2.8.5.201 -Force -ErrorAction Stop | Out-Null Install-Module AzureAD -Force -ErrorAction Stop } catch { Write-Host -ForegroundColor Red \u0026#34;Failed to install the AzureAD PowerShell Module `n$($Error[0])\u0026#34; break } } } else { Write-Host -ForegroundColor Green \u0026#34;AzureAD Powershell Module Found\u0026#34; } $AADMod = ($AADMod | Select-Object -Unique | Sort-Object)[-1] $ADAL = Join-Path $AADMod.ModuleBase \u0026#34;Microsoft.IdentityModel.Clients.ActiveDirectory.dll\u0026#34; $ADALForms = Join-Path $AADMod.ModuleBase \u0026#34;Microsoft.IdentityModel.Clients.ActiveDirectory.Platform.dll\u0026#34; [System.Reflection.Assembly]::LoadFrom($ADAL) | Out-Null [System.Reflection.Assembly]::LoadFrom($ADALForms) | Out-Null $UserInfo = Connect-AzureAD # Microsoft Intune PowerShell Enterprise Application ID  $MIPEAClientID = \u0026#34;d1ddf0e4-d672-4dae-b554-9d5bdfd93547\u0026#34; # The redirectURI $RedirectURI = \u0026#34;urn:ietf:wg:oauth:2.0:oob\u0026#34; #The Authority to connect with (YOur Tenant) Write-Host -Foregroundcolor Cyan \u0026#34;Connected to Tenant: $($UserInfo.TenantID)\u0026#34; $Auth = \u0026#34;https://login.microsoftonline.com/$($UserInfo.TenantID)\u0026#34; try { $AuthContext = New-Object \u0026#34;Microsoft.IdentityModel.Clients.ActiveDirectory.AuthenticationContext\u0026#34; -ArgumentList $Auth # https://msdn.microsoft.com/en-us/library/azure/microsoft.identitymodel.clients.activedirectory.promptbehavior.aspx # Change the prompt behaviour to force credentials each time: Auto, Always, Never, RefreshSession $platformParameters = New-Object \u0026#34;Microsoft.IdentityModel.Clients.ActiveDirectory.PlatformParameters\u0026#34; -ArgumentList \u0026#34;Auto\u0026#34; $userId = New-Object \u0026#34;Microsoft.IdentityModel.Clients.ActiveDirectory.UserIdentifier\u0026#34; -ArgumentList ($UserInfo.Account, \u0026#34;OptionalDisplayableId\u0026#34;) $authResult = $AuthContext.AcquireTokenAsync((\u0026#34;https://\u0026#34; + $MSGraphHost),$MIPEAClientID,$RedirectURI,$platformParameters,$userId).Result # If the accesstoken is valid then create the authentication header if($authResult.AccessToken){ # Creating header for Authorization token $AADAccessToken = $authResult.AccessToken return $AADAccessToken } else { Write-Host -ForegroundColor Red \u0026#34;Authorization Access Token is null, please re-run authentication...\u0026#34; break } } catch { Write-Host -ForegroundColor Red $_.Exception.Message Write-Host -ForegroundColor Red $_.Exception.ItemName break } } # Web page used to help with getting the access token  #https://morgantechspace.com/2019/08/get-graph-api-access-token-using-client-id-and-client-secret.html  if (($ClientID) -and ($ClientSecret) -and ($TenantId) ) { #Create the body of the Authentication of the request for the OAuth Token $Body = @{client_id=$ClientID;client_secret=$ClientSecret;grant_type=\u0026#34;client_credentials\u0026#34;;scope=\u0026#34;https://$MSGraphHost/.default\u0026#34;;} #Get the OAuth Token  $OAuthReq = Invoke-RestMethod -Method Post -Uri \u0026#34;https://login.microsoftonline.com/$TenantId/oauth2/v2.0/token\u0026#34; -Body $Body #Set your access token as a variable $global:AccessToken = $OAuthReq.access_token } else { $global:AccessToken = Connect-AzAD_Token } if ($Import) { IF ($ImportJSON){ #$JSON = GET-Content $ImportJSON $JSON = Get-Content $ImportJSON | ConvertFrom-Json | Select-Object -Property * -ExcludeProperty Version,LastModifiedTime,CreatedDateTime,id,supportsScopeTags | ConvertTo-Json Invoke-RestMethod -Method POST -Uri \u0026#34;https://$MSGraphHost/$MsGraphVersion/deviceManagement/deviceConfigurations\u0026#34; -Headers @{Authorization = \u0026#34;Bearer $AccessToken\u0026#34;} -Body $JSON -ContentType \u0026#34;application/json\u0026#34; } else { Write-Host -ForegroundColor RED \u0026#34;You must specify an a JSON file using the -ImportJSON parameter\u0026#34; } } else { $FormattedOutputFolder = \u0026#34;$OutputFolder\\$(Get-Date -Format yyyyMMdd_HH-mm-ss)\u0026#34; IF (!(Test-Path $FormattedOutputFolder)){ try { mkdir $FormattedOutputFolder -ErrorAction Stop | Out-Null } catch { Write-Host -ForegroundColor Red \u0026#34;Failed to create $FormattedOutputFolder\u0026#34; $Error[0] break } } Invoke-RestMethod -Method GET -Uri \u0026#34;https://$MSGraphHost/$MsGraphVersion/deviceManagement/deviceConfigurations\u0026#34; -Headers @{Authorization = \u0026#34;Bearer $AccessToken\u0026#34;} | Select-Object -ExpandProperty \u0026#34;Value\u0026#34; | %{ $_ | ConvertTo-Json | Out-File \u0026#34;$FormattedOutputFolder\\$($_.displayname).json\u0026#34; } } Pre-Reqs Azure AD App Registration To make the script work without any interaction you will need an Azure App Registration with the following permissions for the Microsoft Graph API.\nBacking Up Device Configuration Profiles  DeviceManagementConfiguration.Read.All (Application Permission)  Importing Device Configuration Profiles  DeviceManagementConfiguration.ReadWrite.All (Application Permission)  GRAPH API DOCUMENTATION If you are not executing the script directly, you will also need the Tenant ID and the account that the script will be running as will need permission to the Output folder for backups.\nIf your not sure how to create an Azure AD App Registration head over to one of my other posts by clicking HERE, Don\u0026rsquo;t forget to store your Client ID and Secret securely and also have it to hand for the rest of the post :D.\nExecuting the Script Using Azure AD App Registrations You can run this script directly from a PowerShell console, using Task Scheduler or using a 3rd party automation product that supports PowerShell.\nThe main thing we will go through here is just the parameters and then putting them all together from the command line, it’s really that simple.\nFor Backup Only  Client ID: This is the Client ID for your Azure AD App ClientSecret: The Client Secret for the Azure AD App TenantID: Your Azure Tenant ID OutputFolder: Your desired Output folder  ./Backup_Import_DeviceConfigurationPolicies.ps1 -ClientID “” -ClientSecret “” -TenantID “” -OutputFolder “./YourServerBackups/ConfigurationPolicies” For Importing Policies  Client ID: This is the Client ID for your Azure AD App ClientSecret: The Client Secret for the Azure AD App TenantID: Your Azure Tenant ID Import: This is a switch parameter which states if your intention is to import or not ImportJSON: the path to your JSON file.  You will finally end up with something like this; ./Backup_DeviceConfigurationPolicies.ps1 -ClientID “” -ClientSecret “” -TenantID “” -Import -ImportJSON “./YourServerBackups/ConfigurationPolicies/ImportMe.JSON”\nDirect Execution If you launch the script without the Client ID, Secret and Tenant ID you will be prompted with a Microsoft Logon Window similar to the below. Once you login the script will continue to run and then output the configuration files in the same way it would using the App Registration. You will need an account with permissions to be able to read (for backups only) or Read and Write the Device Configuration Profiles. However the likelihood is that if you are looking at this guide you are probably an Intune Service Administrator or Global Administrator on your Tenant.\nWhen you run it directly without any switches the script will prompt you to log in and it would only perform a backup of your profiles and output the configurations to the the folder you are executing it from.\nIf you add the -OutputFolder parameter you can change the destination of the base output folder. However if you are wishing to use the script to Import policies you can add the -Import and -ImportJSON parameters, If you specify the -Import  parameter you must also specify the -ImportJSON parameter with a path to the JSON file (e.g. C:/ImportMe.json) otherwise the script will display a message that you did not specify the -ImportJSON Parameter.\nYou will notice that when you run the script, if the folder does not exist it will create it. It also put its into a dated folder in the yyyyMMdd_HH-mm-ss format leaving you with something like 20200901_16_05_36\nSummary This can also be useful if you are wanting to make a copy of your policies to assign to a test machine. All you will need to do is backup your current policies and amend the JSON file, If you find the displayName field in the JSON file and amend it and save the file you will be able to re-import this the same settings. All you then need to do is assign it.\nI have tested this myself at the time of writing the post but if you come across any information you think may be wrong then please leave a comment or e-mail me on david@euc365.com.\n","date":"2 September, 2020","image":["images/post/backupconfigprofile/FeaturedImage.jpg"],"permalink":"https://euc365.com/backup-and-import-intune-device-configuration-profiles/","tags":["Azure App Registrations","Powershell","Intune","Microsoft Graph API","Configuration Profiles"],"title":"Backup and Import Intune Device Configuration Profiles"},{"categories":["Azure","Powershell","Intune"],"contents":"Have you ever needed to add a device to an Azure AD Group as part of your MEMCM or Autopilot deployment for specific app, profiles or scripts?\nWell it became the case that my organisation needed to do so for a couple of reason, one of those was to disable Windows Hello and the other for devices migrating from a previous Configuration Manager (Not MEMCM).\nBecause I was using Hybrid AD Join Autopilot Deployments it became the case that I had to use the devices' computer name and get the device information that way.\nFor you that don\u0026rsquo;t use the Hybrid AD Join Autopilot method, This creates two Azure AD computers, The first been purely Azure AD Joined and the second is an Intune (MDM Enrolled) object. Microsoft do link these together for the Bitlocker Keys etc. and from my understanding they are looking at making them just one object but at the time this article was written they remain two separate objects\u0026hellip;. I look forward to the day when two become one ;).\nOh\u0026hellip; did I also mention that you do not need to install any other modules for PowerShell to be able to run these script? No? Well that\u0026rsquo;s the nature of the game for me is to have as little reliance on Modules etc so the scripts can be run practically anywhere :D.\nThe Script You will notice that most of this (the authentication part and most of the param block at least) are the same as my other script\u0026hellip; But if its not broke why fix it? (Those famous last words!!!).\nAs mentioned above you will notice that this uses the computer name to identify the device and then use the information from that device object to add it to the Azure AD Group. When the device is identified from the name it gets the device Azure ID and then proceeds to create the JSON body for the request and then submits this to the API.\nparam( [Parameter(DontShow = $true)] [string] $MsGraphVersion = \u0026#34;beta\u0026#34;, [Parameter(DontShow = $true)] [string] $MsGraphHost = \u0026#34;graph.microsoft.com\u0026#34;, #The AzureAD ClientID (Application ID) of your registered AzureAD App [string] $ClientID = \u0026#34;\u0026lt;YourClientID\u0026gt;\u0026#34;, #The Client Secret for your AzureAD App [string] $ClientSecret = \u0026#34;\u0026lt;YourClientSecret\u0026gt;\u0026#34;, #Your Azure Tenent ID [string] $TenantId = \u0026#34;\u0026lt;YourTenentID\u0026gt;\u0026#34;, #The Azure AD Group Object ID [string] $GroupID = \u0026#34;\u0026lt;YourGroupID\u0026gt;\u0026#34;, #The name of the device [string] $InputDevice ) IF (!($InputDevice)) { $InputDevice = $env:COMPUTERNAME } #Create the body of the Authentication of the request for the OAuth Token $Body = @{client_id=$ClientID;client_secret=$ClientSecret;grant_type=\u0026#34;client_credentials\u0026#34;;scope=\u0026#34;https://$MSGraphHost/.default\u0026#34;;} #Get the OAuth Token  $OAuthReq = Invoke-RestMethod -Method Post -Uri \u0026#34;https://login.microsoftonline.com/$TenantId/oauth2/v2.0/token\u0026#34; -Body $Body #Set your access token as a variable $global:AccessToken = $OAuthReq.access_token $GroupMembers = Invoke-RestMethod -Method Get -uri \u0026#34;https://$MSGraphHost/$MsGraphVersion/groups/$GroupID/members\u0026#34; -Headers @{Authorization = \u0026#34;Bearer $AccessToken\u0026#34;} | Select-Object -ExpandProperty Value $Devices = Invoke-RestMethod -Method Get -uri \u0026#34;https://$MSGraphHost/$MSGraphVersion/devices?`$filter=startswith(displayName,\u0026#39;$InputDevice\u0026#39;)\u0026#34; -Headers @{Authorization = \u0026#34;Bearer $AccessToken\u0026#34;} | Select-Object -ExpandProperty Value | %{ if ($GroupMembers.ID -contains $_.id) { Write-Host -ForegroundColor Yellow \u0026#34;$($_.DisplayName)($($_.ID)) is in the Group\u0026#34; } else { Write-Host -ForegroundColor Green \u0026#34;Adding $($_.DisplayName)($($_.ID)) To The Group\u0026#34; $BodyContent = @{ \u0026#34;@odata.id\u0026#34;=\u0026#34;https://graph.microsoft.com/v1.0/devices/$($_.id)\u0026#34; } | ConvertTo-Json Invoke-RestMethod -Method POST -uri \u0026#34;https://$MSGraphHost/$MsGraphVersion/groups/$GroupID/members/`$ref\u0026#34; -Headers @{Authorization = \u0026#34;Bearer $AccessToken\u0026#34;; \u0026#39;Content-Type\u0026#39; = \u0026#39;application/json\u0026#39;} -Body $BodyContent } } The Pre-Reqs To make the script work you will need an Azure App Registration with the following permissions for the Microsoft Graph API;\n GroupMember.ReadWrite.All Group.ReadWrite.All Directory.ReadWrite.All  GRAPH API DOCUMENTATION You will also need the Group ID and Tenant ID, to find this following these steps\n Login to the Azure AD console (You can get your Tenant ID from the Overview tab under Tenant Information) Select Groups Search for the group you want to utilise and open it From the Group overview page copy the Object ID as this is the Group ID we need.  If your not sure how to create an Azure AD App Registration head over to one of my other posts by clicking HERE, Don't forget to store your Client ID and Secret securely and also have it to hand for the rest of the post :D. Executing the Script There are numerous ways you can execute this script, you could use it as a script in Script in MEMCM or Intune, In a Task Sequence, as an Application or Package (You will need to add some for of check file for the detection rule) or you could execute this directly from the command line.\nI will demonstrate the Script in MEMCM and Intune for you.\nScript in MEMCM This is the best option if you want to do it manually on a case by case basis (i.e. Right click on the computer object and select run script).\nJump into the Script section in MEMCM (Software Library \u0026gt; Scripts) and click Create Script from the ribbon.\nGive the script a Name, select the language as PowerShell and then copy and paste the script above (Tip: In the top right corner of the script block you can click Copy Script Text).\nClick Next, This is where you need the details we noted earlier. MEMCM is great at pulling through the Param block parameters, all we need to do is amend the ClientID, ClientSecret and TenantId arguments as below.\nAs we are using the environment variable for the InputDevice we will need to Hide this from selection as the script will use the Environment Variable if the parameter is not used.\nDouble Click on InputDevice, Change the Hidden drop down to True click OK.\nWhen finished click Next review the settings and then click next and then close.\n Don\u0026rsquo;t forget to Approve your Script\n Now lets choose a client computer from Assets and Compliance \u0026gt; Devices. Right click on the object and select Run Script, Select the script object you created and review the details and then let the script run.\nThis does not take long to run and the output of the script if the device is successfully added to the group is as below;\nAs mentioned before as these devices are Hybrid Joined they have two entries in Azure AD which is why the output shows its adding the device twice with two different GUIDS.\nScript in Intune This time the script needs to be saved as a .ps1 file to be uploaded and used by Intune, unfortunately using the Scripts section in Intune you cannot specify parameters so you will need to put your Client ID, Secret, TenantID and Group ID into the script before uploading. You could use a Win32 App as an alternative method if you wish to use them via the command line. Once you\u0026rsquo;ve saved the script launch the Endpoint Manager Console from your favourite web browser.\nSelect Devices from the left hand pane, under the Policy section click Scripts.\nClick Add \u0026gt; Windows 10, Name your script appropriately and enter a short description (Even a link to this blog :P), Once you\u0026rsquo;ve done hit next and then select your script to use.\nLeave all of the sliders as No;\nClick Next, Add your Scope Tags (if any) and your assignments. Review the configuration and click Add.\nThis doesn\u0026rsquo;t run instantaneously, please refer to the Microsoft Documentation this also has some other notable consideration listed.\nTo Conclude These are just two of the ways you can run the script, you could also potentially run this in the back end of a web application for people who want to request to disable things like Windows Hello (As I mentioned at the start). I could spent days, weeks even months on writing articles for some of the uses. A user one will no doubt follow in due course so watch this space :D.\nI did fully test these methods at the time of writing the blog but if you come across any information you think may be wrong then please leave a comment or e-mail me on David@euc365.com.\nI hope this is useful for your needs.\n","date":"11 August, 2020","image":["images/post/addtoaadgroup/Featuredimage.png"],"permalink":"https://euc365.com/add-devices-to-an-azure-ad-group-using-the-microsoft-graph-api/","tags":["Azure","Azure AD","Azure App Registrations","Powershell","Intune","Microsoft Graph API"],"title":"Add devices to an Azure AD Group using the Microsoft Graph API"},{"categories":["Powershell","Autopilot","Intune"],"contents":"I have been working on a project at the company I work for, and up to this point we have been primarily focused on getting new devices imported and deploying via Autopilot.\nNow we have successfully leaped over that hurdle with very little issues (apart from the odd TPM attestation issue here and there and the ESP Profile page been skipped), we moved onto focusing on our current estate and how to import these into Autopilot .\nThere is a couple of ways to do this, you could run this in a package, as an application, as a script or in a task sequence for when you decide to re-build the machines.\nNow the choice is yours on which method will suit your organization the best.\nThe Script Now on GitHub\nNow, lets talk about the script itself. When I started out on this path I used Michael Niehaus' Get-WindowsAutoPilotInfo script, even before this had the -online parameter. I was also hoping to leverage the same script for importing devices into Autopilot silently.\nThere was however a couple of stumbling blocks for me not doing so, the first been the Connect-MSGraph would not connect using the ClientID and Secret from the Azure App Registration and kept prompting for credentials. The second being it downloaded other PowerShell Modules. This was an issue for us as firstly it added a further time delay to the script and secondly one of our security product blocked it during this process.\nI had also recently started leveraging the Microsoft Graph API and decided to find a way to do this without additional the modules while achieving the same outcome. And the following is the outcome.\nI have recently updated the script (28/08/2020) to include the use of Group Tags, but also to add the -Hash parameter. The hash parameter allows you to use any device has to register it with your tenant, for example if you had a folder with a set of .csv files containing the device hash\u0026rsquo;s you could do a recursive import of all of these.\nIf you want to export a device hash to a CSV file to test this use the following command which will create the CSV.\nYou can either copy and paste the hash or import the CSV into PowerShell and reference it that way.\nGet-CimInstance -Namespace root/cimv2/mdm/dmmap -Class MDM_DevDetail_Ext01 -Filter \u0026#34;InstanceID=\u0026#39;Ext\u0026#39; AND ParentID=\u0026#39;./DevDetail\u0026#39;\u0026#34; | Export-CSV \u0026#34;C:\\$($ENV:ComputerName)_HardwareInformation.csv\u0026#34; -NoTypeInformation \u0026lt;#PSScriptInfo .VERSION 2.0 .AUTHOR David Brook .COMPANYNAME EUC365 .COPYRIGHT .TAGS Autopilot; Intune; Mobile Device Management .LICENSEURI .PROJECTURI .ICONURI .EXTERNALMODULEDEPENDENCIES .REQUIREDSCRIPTS .EXTERNALSCRIPTDEPENDENCIES .RELEASENOTES Version 2.0: Added the ability to make the script accept command line arguments for just the Hash and also allow Group Tags Version 1.0: Original published version. #\u0026gt; \u0026lt;# .SYNOPSISThis script will import devices to Microsoft Endpoint Manager Autopilot using the device\u0026#39;s hardware hash. .DESCRIPTIONThis script will import devices to Microsoft Endpoint Manager Autopilot using the device\u0026#39;s hardware hash with the added capability of been able to add a Group Tag. .PARAMETERMSGraphVersion The Version of the MS Graph API to use Default: Beta e.g: 1.0 .PARAMETERMsGraphHost The MS Graph API Host Default: graph.microsoft.com .PARAMETERClientID This is the Azure AD App Registration Client ID .PARAMETERClientSecret This is the Azure AD App Registration Client Secret .PARAMETERTenantId Your Azure Tenant ID .PARAMETERHash This parameter is to be used if you want to import a specific hash from either a file or copying and pasting from an application. .PARAMETERGroupTag This Parameter is to be used if you want to Tag your devices with a specific group tag. .EXAMPLE.\\Enroll_to_Autopliot_Unattended.ps1 -ClientID \u0026#34;\u0026lt;Your Client ID\u0026gt;\u0026#34; -Client Secret \u0026#34;\u0026lt;YourClientSecret\u0026gt;\u0026#34; -TenantID \u0026#34;\u0026lt;YourTenantID\u0026gt;\u0026#34; This will enroll the device it is running on to Autopilot, Please note this will need to be done as an administrator .EXAMPLE.\\Enroll_to_Autopliot_Unattended.ps1 -ClientID \u0026#34;\u0026lt;Your Client ID\u0026gt;\u0026#34; -Client Secret \u0026#34;\u0026lt;YourClientSecret\u0026gt;\u0026#34; -TenantID \u0026#34;\u0026lt;YourTenantID\u0026gt;\u0026#34; -GroupTag \u0026#34;Sales Device\u0026#34; This will enroll the device it is running on to Autopilot with a Group Tag of Sales Device, Please note this will need to be done as an administrator .EXAMPLE.\\Enroll_to_Autopliot_Unattended.ps1 -ClientID \u0026#34;\u0026lt;Your Client ID\u0026gt;\u0026#34; -Client Secret \u0026#34;\u0026lt;YourClientSecret\u0026gt;\u0026#34; -TenantID \u0026#34;\u0026lt;YourTenantID\u0026gt;\u0026#34; -Hash \u0026#34;\u0026lt;A Hash\u0026gt;\u0026#34; This will enroll the inputed deivce Hash to Autopilot, this can be done against a group of CSV files etc. #\u0026gt; param( [Parameter(DontShow = $true)] [string] $MsGraphVersion = \u0026#34;beta\u0026#34;, [Parameter(DontShow = $true)] [string] $MsGraphHost = \u0026#34;graph.microsoft.com\u0026#34;, #The AzureAD ClientID (Application ID) of your registered AzureAD App [string] $ClientID = \u0026#34;\u0026lt;YourClientID\u0026gt;\u0026#34;, #The Client Secret for your AzureAD App [string] $ClientSecret = \u0026#34;\u0026lt;YourSecret\u0026gt;\u0026#34;, #Your Azure Tenent ID [string] $TenantId = \u0026#34;\u0026lt;YourTenant\u0026gt;\u0026#34;, [string] $Hash, [string] $GroupTag ) Begin { #Create the body of the Authentication of the request for the OAuth Token $Body = @{client_id=$ClientID;client_secret=$ClientSecret;grant_type=\u0026#34;client_credentials\u0026#34;;scope=\u0026#34;https://$MSGraphHost/.default\u0026#34;;} #Get the OAuth Token  $OAuthReq = Invoke-RestMethod -Method Post -Uri \u0026#34;https://login.microsoftonline.com/$TenantId/oauth2/v2.0/token\u0026#34; -Body $Body #Set your access token as a variable $global:AccessToken = $OAuthReq.access_token } Process { if(!$Hash) { $session = New-CimSession # Get the common properties. Write-Verbose \u0026#34;Checking $comp\u0026#34; $serial = (Get-CimInstance -CimSession $session -Class Win32_BIOS).SerialNumber # Get the hash (if available) $devDetail = (Get-CimInstance -CimSession $session -Namespace root/cimv2/mdm/dmmap -Class MDM_DevDetail_Ext01 -Filter \u0026#34;InstanceID=\u0026#39;Ext\u0026#39; AND ParentID=\u0026#39;./DevDetail\u0026#39;\u0026#34;) if ($devDetail) { $hash = $devDetail.DeviceHardwareData } else { $hash = \u0026#34;\u0026#34; } Remove-CimSession $session } } End { if(!($GroupTag)) { $PostData = @{ \u0026#39;hardwareIdentifier\u0026#39; = \u0026#34;$hash\u0026#34; } | ConvertTo-Json } else { $PostData = @{ \u0026#39;hardwareIdentifier\u0026#39; = \u0026#34;$hash\u0026#34; \u0026#39;groupTag\u0026#39; = \u0026#34;$GroupTag\u0026#34; } | ConvertTo-Json } $Post = Invoke-RestMethod -Method POST -Uri \u0026#34;https://$MSGraphHost/$MsGraphVersion/devicemanagement/importedWindowsAutopilotDeviceIdentities\u0026#34; -Headers @{Authorization = \u0026#34;Bearer $AccessToken\u0026#34;; \u0026#39;Content-Type\u0026#39; = \u0026#39;application/json\u0026#39;} -Body $PostData DO { Write-Host \u0026#34;Waiting for device import\u0026#34; Start-Sleep 10 } UNTIL ((Invoke-RestMethod -Method Get -Uri \u0026#34;https://$MsGraphHost/$MsGraphVersion/Devicemanagement/importedwindowsautopilotdeviceidentities/$($Post.ID)\u0026#34; -Headers @{Authorization = \u0026#34;Bearer $AccessToken\u0026#34;} | Select-Object -ExpandProperty State) -NOTmatch \u0026#34;unknown\u0026#34;) Invoke-RestMethod -Method Get -Uri \u0026#34;https://$MsGraphHost/$MsGraphVersion/Devicemanagement/importedwindowsautopilotdeviceidentities/$($Post.ID)\u0026#34; -Headers @{Authorization = \u0026#34;Bearer $AccessToken\u0026#34;} | Select-Object -ExpandProperty State } The Pre-Reqs To make the script work you will need an Azure App Registration with the DeviceManagementServiceConfig.ReadWrite.All permission for the Microsoft Graph API.\nIf your not sure how to create an Azure AD App Registration head over to one of my other posts by clicking HERE, Don\u0026rsquo;t forget to store your Client ID and Secret securely and also have it to hand for the rest of the post :D.\nExecuting the Script As mentioned before there are numerous ways you can run this script, however I will demonstrate 2 different ways to do so, I will just mention though that if you do use this as an Application you will need to amend the script to add some form of check file or registry key.\nScript in MEMCM This is the best option if you want to do it manually on a case by case basis (i.e. Right click on the computer object and select run script).\nJump into the Script section in MEMCM (Software Library \u0026gt; Scripts) and click Create Script from the ribbon.\nGive the script a Name, select the language as PowerShell and then copy and paste the script above (Tip: In the top right corner of the script block you can click Copy Script Text).\nClick Next, This is where you need the details we noted earlier. MEMCM is great at pulling through the Param block parameters, all we need to do is amend the ClientID, ClientSecret and TenantId arguments as below. When finished click Next review the settings and then click next and then close.\nDon\u0026rsquo;t forget to Approve your Script\n Now choose your victim\u0026hellip; erm I mean client computer from Assets and Compliance \u0026gt; Devices. Right click on the object and select Run Script, Select the script object you created and review the details and then let the script run :D. This can take about 2/5 minutes, as it keeps a loop going until the device is imported. When the script finishes if you look at the script out put you will see the following;\nIf you notice the last output shows the import status of the device.\nIn a Task Sequence in MEMCM I wont go into how to create the entire Task Sequence for a device rebuild however I will explain how you can use the script to import the device into Autopilot during a Task Sequence weather it be a new one or a current one.\nHead over to Software Library \u0026gt; Operating System \u0026gt; Task Sequences so we can get started.\nI will be using a current Task Sequence for this Demo. There may be a future post on how to create a Task Sequence to re-build your device to a standard OS with Drivers and Import it to Autopilot.\nMy existing Task Sequence looks like this;\nThis is a very basic TS which just boots to Win PE, Installs windows and loads driver packs for VMware Virtual Machines (Only a test TS).\nI no longer want to have to re-build the device and then import it to Autopilot Manually so instead we add the script to the top of the TS as follows.\n Click Add \u0026gt; General \u0026gt; Run Powershell Script  Enter a Name and Description for the script Select Enter a PowerShell Script Click Add Script Copy the Script above and paste it into the window and click OK In the Parameters box enter  -ClientID \"\" -ClientSecret \"\" -TenantId \"\"   Select Bypass under the PowerShell Execution Policy drop-down  Your window should then look like this;\nHit Apply and then OK and give it a whirl on your machine (well not yours\u0026hellip; always be sure to test it first :P)\nWhen it runs you will see the following appear (depending on your Task Sequence);\nThe device will then be enrolled into Autopilot;\nWhen the device then reboots after my task sequence I am presented with the expected Autopilot Enrolment window.\nTo Conclude So I have shown two ways of using the script to enroll to Autopilot Unattended, now there is nothing preventing you running this from the command line with the same parameters however if you wanted to do it that way I would definitely look at Michael Niehaus' Get-WindowsAutopilotInfo script (See the opening few paragraphs with the links to these) as this does not require an App Registration.\nI did fully test these methods at the time of writing the blog but if you come across any information you think may be wrong then please leave a comment or e-mail me on David@euc365.com.\nI hope this is useful for your needs.\n","date":"7 August, 2020","image":["images/post/enroltoap/featuredImage.png"],"permalink":"https://euc365.com/enrol-devices-to-autopilot-unattended/","tags":["Azure App Registrations","Powershell","Intune","Microsoft Graph API","Autopilot"],"title":"Enrol Devices to Autopilot (Unattended)"},{"categories":["Azure"],"contents":"What can you use an Azure App Registration for An Azure App Registration has many uses, in my case I use it mainly for the Microsoft Graph API to perform Intune Configuration Profile backups, List devices, Update local CMDB dynamically and also enrol devices into Autopilot.\nYou will see the vast amount of options you can use for the API when you start adding the API permissions below.\nIf you are also using MEMCM and Co-Managing devices with Intune or you have this Azure Tenant attached this will also be using an Azure App Registration to read user details and use user impersonation.\nHowever as you will notice this guide is focused on using the App Registration with the Microsoft Graph API with Client Secrets.\nFinding what API Permission is required for your Microsoft Graph API Call Each API can have a different set of permissions required to be able to read and/or write data. The best way to find these is by using the Microsoft Graph API Reference Guide .\nOnce you have loaded the API Reference guide, you will notice a list of categories for the API like below.\nFor this post I am using the importedWindowsAutopilotDeviceIdentities API reference which is in the Beta API. You can change what API Reference you are using by using the drop down under the Version header in the left-hand pane.\nIf you browse to Devices and apps \u0026gt; Corporate management \u0026gt; Imported windows autopilot device identity \u0026gt; List, You will see under the prerequisites which permissions that particular API requires as highlighted below.\nI will be using the Application permissions as the App this was created for is unattended\n You will notice that even though you are only listing devices that the ReadWrite permission is listed in the permission set. If you look closer at the permission table headers you will see it states Permissions (from most to least privileged) meaning that to use the full functionality of this API (such as Create, Delete and Update) you will need the ReadWrite permission, However if you just wanted to list the data you would only need the least amount of privileges which is Read.\nHave a browse around and notice the differences in different categories before moving on.\nCreating the Azure App Registration Head over to the Azure Portal  and launch Azure Active Directory.\nFrom the pane on the left select \u0026lt;strong\u0026gt;App Registrations\u0026lt;/strong\u0026gt; , from here you can either choose to use an existing registrations or create one for this specific purpose. I would however recommend that you use a specific one for this purpose, this way the app does not have more permissions than it requires.\nLets get started;\n Click New Registration from the ribbon Give the App a name that represents its purpose and leave the rest as default and click Register   From the left pane, select API Permissions, This is where we are going to grant the App the permission to the Microsoft Graph API Select Add a permission from the ribbon, you will see a pop out like the below;   Click on Microsoft Graph \u0026gt; Application Permissions In the search box type Service and this will show the permissions we require   Click Add Permissions You will then see a orange banner stating that the permissions are being edited and consent will need to be given   Click the Grant admin consent for, click Yes on the banner to confirm your would like to grant consent  \n Next we need a client secret... you will need to store this in a safe place as once you click of the page its hides all but a few characters. Click Client \u0026amp; Secrets from the pane on the left Click New Client Secret  Specify a description, if you are going to put this in numerous locations and let multiple people use it you could relate it to that team/department. But for this example we will keep it simple. Specify a validity period, you have three options, 1 year, 2 years or never. I would not recommend using the later and would ensure that you have processes in place to review the application     When you have added the secret, copy the value as you will need this later.  To go with the client secret you will also need the Application (Client) ID and the Directory (tenant) ID. These can be found on the Overview page.\nThe details you have gathered from this article you can use them to perform unattended actions on the Microsoft Graph API and other services. I will be posting some other blog posts which relate to using these details so keep an eye on the blog for interesting ways to use the App Registrations.\n","date":"8 July, 2020","image":["images/post/createazureapp/featuredImage.png"],"permalink":"https://euc365.com/create-an-azure-app-registration/","tags":["Azure","Azure AD","Azure App Registrations"],"title":"Create an Azure App Registration"},{"categories":["Intune","PowerShell","Group Policy"],"contents":"What is an OMA-URI Policy? Meaning: Open Mobile Alliance Uniform Resource Identifier Traditionally when you implement a new piece of software which contains Group Policy Objects (GPO\u0026rsquo;s) to customise the feature of the application you would import the .adml and .admx files into the PolicyDefinitions folder located within SysVol (SYSVOL) for the domain or into the local PolicyDefinitions (C:\\WindowsPolicyDefinitions) folder.\nIf like me you are wanting to move most if not all of your policies to Intune for better MDM (Mobile Device Management) then you can run into a rather complex scenario where you need to ingest the .admx file and then work out how to configure your policies correctly. Now the first time I looked at this I thought \u0026lsquo;Oh man this looks tricky, its a job for later on\u0026rsquo;. However after putting it off for so long I finally dived into it and it turns out it isn\u0026rsquo;t as complicated as it looks.\nThe link to the Microsoft Guide can be found HERE!! , Feel free to head over and check it out. Hopefully this post/guide can help you out when it comes to creating your own.\nImporting your ADMX file For this example we will be using Google Chrome\u0026rsquo;s GPO\u0026rsquo;s, Not because they are simple because each policy has its own complexities but because it will be a common policy people will look to migrate to Intune. The ADMX files can be found on the Chrome for Enterprise Download Page , you can obtain the gpo files only be finding the Manage Chrome Browser section.\nOnce downloaded extract the .zip file and find the Chrome.admx (Normally located within WindowsADMX), Open this in a text editor (Notepad will do fine). Now we will switch over to Intune, From the Endpoint Manager Admin Center Homepage select Devices \u0026gt; Configuration Profiles from the navigation bar. Click Create profile.\n Click Create Profile Select the following and click Create;   Enter the name for your profile (i.e Windows - Google Chrome Policy) and any other information you wish to add, click Next Now here is the fun part, Click Add   Enter a Name (Use something Descriptive) and Enter a description The OMA-URI Field Should be something like the below  ./Vendor/MSFT/Policy/ConfigOperations/ADMXInstall/{AppName}/Policy/{ADMXFileName}   Data Type: String Value: Paste the contents of the chrome.admx file   Click Add Now Proceed to deploy the policy (I would recommend doing this to a test group first)  The above path determines what the OMA-URI is for future policies, for example if you enter ./Vendor/MSFT/Policy/ConfigOperations/ADMXInstall/Chrome/Policy/ChromeAdmx as the OMA-URI for the device import the policies within the ADMX will then be formatted like Chrome~Policy~googlechrome~Startup.\nThe full path for the OMA-URI for the Homepage Setting would be ./{AppName}/Vendor/MSFT/Policy/Config/Chrome~Policy~googlechrome~Startup/HomepageLocation. The format of the URI is is {AppName}~{SettingType}~{CategoryandSubCategory}.\nNow the category path may not just be a root category for example the startup settings will look like this Chrome~Policy~googlechrome~Startup to break it down\n AppName: Chrome (Set in the ADMX File Ingest) SettingType: Policy (Set in the ADMX File Ingest) CategoryAndSubCategory:  Category: googlechrome Sub Category: Startup    Now this may seem complicated at first glance, however do keep reading and I will explain how to obtain the paths and settings.\n\nFinding and Creating Policies Before we get started, if you haven\u0026rsquo;t already re-open the properties of the policy you created previously. You will also need to open the .admx files in your favourite text editor. Personally I use VSCode as it has syntax highlighting for XML files and many other useful features.\nThis section requires this to be published to a device.\n To get started Open the Chrome.admx and Chrome.adml (This will be in the language folder i.e. en-US within the .zip file) and launch REGEDIT (Registry Editor).\nLet\u0026rsquo;s get started, within REGEDIT browse to HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/PolicyManager/AdmxDefault (There is always a random GUID per device, however this doesn\u0026rsquo;t make a difference to the policy so don\u0026rsquo;t worry), from here if you deployed the Chrome Policy as per the above steps you will see something like the below. (Note: this is showing Google Updates, but we will\nAs mentioned above they are broken down like below, we will be sticking with the Homepage setting which is within the startup category.\n AppName: Chrome SettingType: Policy Categories:  Root Category: googlechrome Sub Category: startup    Now if you look at the .admx file, you will see the following under the categories section\nAs you can see that this correlates with with policy in the registry, now if you expand the policy within the registry you can see that the HomePage Location settings is created from within there\nThis is the part where you actually need the .admx file. Lets start by explaining why you need to use .admx file. For this example you are not only enabling or disabling a policy but you will be actually specifying a value. When you go to specify this value in Intune you will need to use the ValueName from within the ADMX File. See the below example;\nLets break the policy setting down first, As always I would recommend naming the setting descriptively and also adding a description if you want more information about it. The OMA-URI would then be ./Device/Vendor/MSFT/Policy/Config/Chrome~Policy~googlechrome~Startup/HomepageLocation.\nClass (Device or User) One things to note here is the first section of the OMA-URI, It seems simple but you will need to specify if you want to apply this to a Device or User. Some policies are only available for Devices and likewise for Users. You can see this in the ADMX File by looking at the policy like below\nNow the HomePageLocation setting can be User or Device based so the class shows as Both. If this was a device only policy class=\u0026ldquo;Machine\u0026rdquo; and for a user only policy it would show as class=\u0026ldquo;User\u0026rdquo;.\nAppName As mentioned above the AppName is can be totally customisable however I wouldn\u0026rsquo;t advise that and I would keep it as simple and descriptive as possible.\nFor example, For this post I used Chrome as the AppName so the Policies show as Chrome~{SettingType}~{Root Category}~{Sub** **Category}. If i was to do another policy for Lenovo Vantage for example and set the AppName to LenovoVantage the polcies would show LenovoVantage~{SettingType}~{Root Category}~{Sub Category}.\nSettingType As we imported the ADMX into the Policy section (./Vendor/MSFT/Policy/ConfigOperations/ADMXInstall/{AppName}/Policy/{ADMXFileName}) of the ADMXInstall OMA-URI this part of the OMA-URI would always be policy.\nCategories and Sub-Categories This is detailed above but I will elaborate a little bit more here.\nIf you look at the .admx file, and browse to the categories section you will see lots of categories set with a parent category within there.\nIf you work backwards you can see how this all comes together,\nThe OMA-URI is Chrome~Policy~{Root Category}~{Sub Category}\n Sub Category: Startup Root Category: googlechrome  Something to not here is that it is possible for a parent category to have another parent category to make matters more confusing. You could end up having a policy like {AppName}~Policy~{Parent Category 1}~{Parent Category 2}~{Sub Category} and so on\u0026hellip; Just something to always check.\nThis is partly the reason to always check the registry when creating polices.\nThe Policy Itself So finally we come to the policy itself, at the end all the OMA-URI string comes the setting, in this case HomePageLocation.\nThis is derived again from the .admx file, if you search for the policy you will come across something like the above screenshot. You will notice that the policy is based on the DisplayName property. We won\u0026rsquo;t cover setting the value in this section as I feel it deserves its own.\nThe Policy Value/Setting Some setting are really simple to configure, for example if you want to disable something like MetricsReportingEnabled you can simply just add like below\nOthers like the HomePageLocation are not complicated but require a little bit more than just a simple disable or enable switch as you need to specify a value for the property.\nAgain jumping back into the .admx file, if you look at the last highlighted section of the below screenshot you can see that there is a ValueName, now this is the value we need want to change.\nto do this you would need to write the policy string like the below screenshot\nIf you look at the data id section, this is where you would put the value name in out of the .admx file, from there you would then set the value of that property for example https://euc365.com.\nIf you apply this policy and sync it to your device you will notice that it will change the Homepage upon start up.\nNow\u0026hellip; Here is another example of adding a string to a policy which requires multiple values. This once is not so much tricky but its messy.\nFor this example we will use the Allow Pop ups for certain sites, I will start off by showing you the screenshot of the policy itself\nYou will notice that at the start and end of each URL there is a rather ugly looking set of characters, now this is where is can get messy. The pre-URL string is the only one that needs to be changed per entry. If you think of this like a list, option 1 in the list is http://euc365.com and option 2 is http://bbc.co.uk, As you can see in the screenshot the pre-URL has a number which needs to be incremented each time you add another URL.\nIf you are just having one URL you don’t need to add the final \u0026amp;#xF000;, However if you are using multiple values you will need to add that to the end of the URL and then follow it up with you next URL.\nThe last URL in the sequence should not be followed by \u0026amp;#xF000;\n Looking at putting the URL together you will end up with something like 1\u0026amp;#xF000; + https://euc365.com + \u0026amp;#xF000; + Following URLs, For a single url it would be 1\u0026amp;#xF000; + https://euc365.com\n","date":"30 June, 2020","image":["images/post/omauri/chromeadmx-300x208.png"],"permalink":"https://euc365.com/breaking-down-custom-oma-uri-csp-policies/","tags":["Intune","Powershell Tools","PowerShell","Configuration Profile","Group Policy"],"title":"Breaking Down Custom OMA-URI (CSP) Policies"},{"categories":["Intune","PowerShell Tools","PowerShell"],"contents":"SO\u0026hellip; I\u0026rsquo;ve been working tirelessly in trying to get an Autopilot Hybrid Deployment working along with my colleagues. As any Tech does I give everything my blood sweat and tears before logging a call with support (Sound silly as we could waste hours\u0026hellip; But where\u0026rsquo;s the fun in just logging a call), however on occasion you have to admit defeat and raise a service request.\nWhen logging an SR (Service Request) its always best to provide as much information about the device you are using (the one that\u0026rsquo;s having the issues) so the Microsoft Engineer can do as much fault finding and troubleshooting that they can before they contact you.\nWhen troubleshooting an Autopilot Deployment its useful to have the following information from a support engineer point of view but it is also helpful when speaking with Microsoft;\n Azure Device ID (GUID) Intune Device ID (GUID) Name (Not vital as it can be obtained from the above) IP Address Logon Server  Useful for Hybrid Deployments in an organisation with multiple Domain Controllers when using Azure AD Connect Device Serial Number (Easiest way to find a device in the Windows Enrolment Devices Screen)\nAll of that information is not just something that you can go grab in one place off of the shelf. Going to obtain all of this information from various locations got very long in the tooth and became a bit of a drag. In true IT fashion I spent hours writing a PowerShell script which Displays as a Windows Form and gathers all of this information and copies it to your clipboard.\nThe form will look like the below when run, It will only display active networks and it can handle more than one network (this is dynamic) and the form will resize dynamically depending on content.\n This will also copy the following information to your clipboard; Computer Name: Device Serial: Device Manufacturer: Device Model: Logon Server: Intune Device ID: AzureAD Device ID: IP Information: Interface Name: WiFi Interface Description: Intel(R) Wi-Fi 6 AX201 160MHz Profile Name: IPv4 Address: 192.168.0.141 IPv6 Address: Interface Name: Microsoft IP-HTTPS Platform Interface Interface Description: Profile Name: IPv4 Address: IPv6 Address: fd59:a9a9:6c55:1000:8c4a:531c:b003:cf56 Information gathered 23/05/2020 22:08:30 The form can be branded, and amended to your hearts content. I have uploaded it to GitHub in a Public Library if anyone wants to head over and download it or Fork it (Still not sure what that does, New to this GitHub stuff). I haven’t got around to putting any information on the GitHub Page yet but it you need any help drop me a message from the Contact page or on the GitHub page.\n","date":"23 May, 2020","image":["images/post/getdeviceinfo/banner.png"],"permalink":"https://euc365.com/getting-useful-device-information-troubleshooting-made-easy/","tags":["PowerShell Tools"],"title":"Getting Useful Device Information… Troubleshooting Made Easy"}]